/*!
 * Data.js Library
 * Copyright(c) 2013 Gregory Jacobs.
 * MIT Licensed. http://www.opensource.org/licenses/mit-license.php
 */
(function(){tests.unit=new Ext.test.TestSuite("unit");tests.unit.attribute=new Ext.test.TestSuite("attribute").addTo(tests.unit);tests.unit.data=new Ext.test.TestSuite("data").addTo(tests.unit);tests.unit.persistence=new Ext.test.TestSuite("persistence").addTo(tests.unit);Ext.test.Session.addSuite(tests.unit)})();tests.unit.add(new Ext.test.TestSuite({name:"Data",items:[{name:"Test namespace()",test_namespace:function(){var a=window;Data.namespace("FooTest1");Y.Assert.isNotUndefined(a.FooTest1,"Test creation with a single top-level namespace");Data.namespace("FooTest2","FooTest3","FooTest4");Y.Assert.isNotUndefined(a.FooTest2,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest3,"Test creation with multiple top level namespaces");Y.Assert.isNotUndefined(a.FooTest4,"Test creation with multiple top level namespaces");Data.namespace("FooTest5","FooTest5.ns1","FooTest5.ns1.ns2","FooTest5.ns1.ns2.ns3");Y.Assert.isNotUndefined(a.FooTest5,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2,"Test a chain of namespaces, starting from a top-level");Y.Assert.isNotUndefined(a.FooTest5.ns1.ns2.ns3,"Test a chain of namespaces, starting from a top-level");Data.namespace("FooTest6.ns1","FooTest7.ns1");Y.Assert.isNotUndefined(a.FooTest6.ns1,"Test creating lower level namespaces without first defining the top level");Y.Assert.isNotUndefined(a.FooTest7.ns1,"Test creating lower level namespaces without first defining the top level");Data.namespace("FooTest8","FooTest8.ns1.ns2");Y.Assert.isNotUndefined(a.FooTest8,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1,"Test creating a lower level namespace without defining the middle level");Y.Assert.isNotUndefined(a.FooTest8.ns1.ns2,"Test creating a lower level namespace without defining the middle level");FooTest8.prop1="foo";Data.namespace("FooTest8");Y.Assert.areEqual("foo",FooTest8.prop1,"Ensure existing namespaces are not overwritten")}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Attribute",items:[{name:"Test constructor",_should:{error:{"Instantiating an Attribute without a 'name' should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor","Instantiating an Attribute with an undefined 'name' argument should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor","Instantiating an Attribute with an undefined 'name' property should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor","Instantiating an Attribute with a null 'name' argument should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor","Instantiating an Attribute with a null 'name' property should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor","Instantiating an Attribute with an empty 'name' argument should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor","Instantiating an Attribute with an empty 'name' property should throw an error":"no 'name' property provided to Data.attribute.Attribute constructor"}},setUp:function(){this.Attribute=Data.attribute.Attribute.extend({})},"Instantiating an Attribute without a 'name' should throw an error":function(){var a=new this.Attribute()},"Instantiating an Attribute with an undefined 'name' argument should throw an error":function(){var a=new this.Attribute(undefined)},"Instantiating an Attribute with an undefined 'name' property should throw an error":function(){var a=new this.Attribute({name:undefined})},"Instantiating an Attribute with a null 'name' argument should throw an error":function(){var a=new this.Attribute(null)},"Instantiating an Attribute with a null 'name' property should throw an error":function(){var a=new this.Attribute({name:null})},"Instantiating an Attribute with an empty 'name' argument should throw an error":function(){var a=new this.Attribute("")},"Instantiating an Attribute with an empty 'name' property should throw an error":function(){var a=new this.Attribute({name:""})}},{name:"Test getName()",setUp:function(){this.Attribute=Data.attribute.Attribute.extend({})},"The name property should be retrievable by getName()":function(){var c=new this.Attribute({name:"testName"});Y.Assert.areSame("testName",c.getName(),"getName() not properly retriving Attribute's name. Was looking for 'testName'.");var b=new this.Attribute({name:"_"});Y.Assert.areSame("_",b.getName(),"getName() not properly retriving Attribute's name. Was looking for '_'.");var a=new this.Attribute({name:"abc"});Y.Assert.areSame("abc",a.getName(),"getName() not properly retriving Attribute's name. Was looking for 'abc'.")},"Providing the attribute name as a number directly to the constructor argument should be converted to a string for the attribute's name":function(){var a=new this.Attribute(0);Y.Assert.areSame("0",a.getName(),"the attribute name should have been converted to a string")},"Providing the attribute name as a property on the config should be converted to a string for the attribute's name":function(){var a=new this.Attribute({name:0});Y.Assert.areSame("0",a.getName(),"the attribute name should have been converted to a string")}},{name:"Test hasUserDefinedSetter()",setUp:function(){this.Attribute=Data.attribute.Attribute.extend({})},"hasUserDefinedSetter() should return false when there is no user-defined setter":function(){var a=new this.Attribute({name:"myAttr"});Y.Assert.isFalse(a.hasUserDefinedSetter())},"hasUserDefinedSetter() should return true when there is a user-defined setter":function(){var a=new this.Attribute({name:"myAttr",set:function(b){return b}});Y.Assert.isTrue(a.hasUserDefinedSetter())}},{name:"Test hasUserDefinedGetter()",setUp:function(){this.Attribute=Data.attribute.Attribute.extend({})},"hasUserDefinedGetter() should return false when there is no user-defined getter":function(){var a=new this.Attribute({name:"myAttr"});Y.Assert.isFalse(a.hasUserDefinedGetter())},"hasUserDefinedGetter() should return true when there is a user-defined getter":function(){var a=new this.Attribute({name:"myAttr",get:function(b){return b}});Y.Assert.isTrue(a.hasUserDefinedGetter())}},{name:"Test getDefaultValue()",setUp:function(){this.Attribute=Data.attribute.Attribute.extend({})},"A default provided as the keyword 'default' should be accepted properly as defaultValue":function(){var a=new this.Attribute({name:"TestAttribute","default":1});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as the keyword 'default' that is a function should be executed and set properly to defaultValue":function(){var a=new this.Attribute({name:"TestAttribute","default":function(){return 1}});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as defaultValue should be accepted properly":function(){var a=new this.Attribute({name:"TestAttribute",defaultValue:1});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as defaultValue that is a function should be executed and set properly to defaultValue":function(){var a=new this.Attribute({name:"TestAttribute",defaultValue:function(){return 1}});Y.Assert.areSame(1,a.getDefaultValue())},"A default provided as defaultValue that is a function should be provided the Attribute instance as its first argument":function(){var b;var a=new this.Attribute({name:"TestAttribute",defaultValue:function(c){b=c;return 1}});a.getDefaultValue();Y.Assert.areSame(a,b)},"A default provided as defaultValue that is a function should be executed each time the default is called for":function(){var a=0;var b=new this.Attribute({name:"TestAttribute",defaultValue:function(){return ++a}});Y.Assert.areSame(1,b.getDefaultValue());Y.Assert.areSame(2,b.getDefaultValue())}},{name:"Test the doSet() method","doSet() should call the Attribute's prototype set() method if there is no 'set' config, with the appropriate arguments":function(){var a=JsMockito.mock(Data.Model),g=42,c=27;var e,h,b;var d=Data.attribute.Attribute.extend({set:function(j,k,i){e=j;h=k;b=i}});var f=new d("attr");f.doSet(a,g,c);Y.Assert.areSame(a,e,"The mock model should have been provided as the first arg to the set() method");Y.Assert.areSame(g,h,"The new value should have been provided as the second arg to the set() method");Y.Assert.areSame(c,b,"The old value should have been provided as the third arg to the set() method")},"doSet() should call a provided 'set' config function if provided to the Attribute, and it should be called in the scope of the model":function(){var b=JsMockito.mock(Data.Model),g=42,d=27;var a,h,c;var e=Data.attribute.Attribute.extend({});var f=new e({name:"attr",set:function(j,i){a=this;h=j;c=i}});f.doSet(b,g,d);Y.Assert.areSame(b,a,"The 'set' config should have been called in the context of the mock model");Y.Assert.areSame(g,h,"The new value should have been provided as the first arg to the set() method");Y.Assert.areSame(d,c,"The old value should have been provided as the second arg to the set() method")}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"BooleanAttribute",items:[{name:"Test getDefaultValue()","getDefaultValue() should return false in the default case (i.e. when the `useNull` config is false)":function(){var a=new Data.attribute.BooleanAttribute({name:"attr",useNull:false});Y.Assert.isFalse(a.getDefaultValue())},"getDefaultValue() should return null when the `useNull` config is true":function(){var a=new Data.attribute.BooleanAttribute({name:"attr",useNull:true});Y.Assert.isNull(a.getDefaultValue())}},{name:"Test beforeSet()","beforeSet() should return the appropriate Boolean when provided a range of values and types, when the useNull config is false":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.BooleanAttribute({name:"attr",useNull:false}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.isFalse(d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.isFalse(d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isFalse(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isTrue(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.isFalse(d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.isTrue(d,"Test with value: 1");d=c.beforeSet(a,"",b);Y.Assert.isFalse(d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isFalse(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isTrue(d,"Test with value: 'true'");d=c.beforeSet(a,{},b);Y.Assert.isFalse(d,"Test with value: {}")},"beforeSet() should return null for 'unparsable' values/types, when the useNull config is true":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.BooleanAttribute({name:"attr",useNull:true}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.isNull(d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.isNull(d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isFalse(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isTrue(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.isFalse(d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.isTrue(d,"Test with value: 1");d=c.beforeSet(a,"",b);Y.Assert.isNull(d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isFalse(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isTrue(d,"Test with value: 'true'");d=c.beforeSet(a,{},b);Y.Assert.isFalse(d,"Test with value: {}")}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Data.attribute.CollectionAttribute",items:[{name:"Test constructor",_should:{error:{"the constructor should throw an error if the undefined value is provided for the collectionClass config, which helps determine when late binding is needed for the collectionClass config":"The 'collectionClass' config provided to an Attribute with the name 'attr' either doesn't exist, or doesn't exist just yet. Consider using the String or Function form of the collectionClass config for late binding, if needed"}},"the constructor should throw an error if the undefined value is provided for the collectionClass config, which helps determine when late binding is needed for the collectionClass config":function(){var a=new Data.attribute.CollectionAttribute({name:"attr",collectionClass:undefined});Y.Assert.fail("The constructor should have thrown an error if the collectionClass config was provided but was undefined. This is to help with debugging when late binding for the collectionClass is needed.")}},{name:"Test valuesAreEqual()",setUp:function(){this.attribute=new Data.attribute.CollectionAttribute({name:"attr"})},"valuesAreEqual() should return true for two null values":function(){var a=this.attribute.valuesAreEqual(null,null);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for one null and one object":function(){var a;a=this.attribute.valuesAreEqual(null,{});Y.Assert.isFalse(a);a=this.attribute.valuesAreEqual({},null);Y.Assert.isFalse(a)},"valuesAreEqual() should return true for comparing the same collection":function(){var b=Data.Collection.extend({}),c=new b();var a=this.attribute.valuesAreEqual(c,c);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for two different collections":function(){var c=Data.Collection.extend({}),d=new c(),b=new c();var a=this.attribute.valuesAreEqual(d,b);Y.Assert.isFalse(a)}},{name:"Test beforeSet()",setUp:function(){this.Model=Data.Model.extend({attributes:["attr1","attr2"]});this.Collection=Data.Collection.extend({model:this.Model});this.attribute=new Data.attribute.CollectionAttribute({name:"attr",collectionClass:this.Collection})},_should:{error:{"beforeSet() should throw an error if the string 'collectionClass' config does not reference a Collection class":"The string value 'collectionClass' config did not resolve to a Collection class for attribute 'attr'","beforeSet() should throw an error if the function value 'collectionClass' config does not reference a Collection class":"The function value 'collectionClass' config did not resolve to a Collection class for attribute 'attr'"}},"beforeSet() should return null when provided any falsy value, or non-object":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.CollectionAttribute({name:"attr"}),b,d;d=c.beforeSet(a,0,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,1,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,"",b);Y.Assert.areSame(null,d);d=c.beforeSet(a,"hi",b);Y.Assert.areSame(null,d);d=c.beforeSet(a,false,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,true,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,undefined,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,null,b);Y.Assert.areSame(null,d)},"beforeSet() should throw an error if the string 'collectionClass' config does not reference a Collection class":function(){var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.CollectionAttribute({name:"attr",collectionClass:"somethingThatIsNotDefined"});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,e,b);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should throw an error if the function value 'collectionClass' config does not reference a Collection class":function(){var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.CollectionAttribute({name:"attr",collectionClass:function(){return}});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,e,b);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should convert an array of data objects, when collectionClass is a direct reference to the Collection subclass":function(){var a=JsMockito.mock(Data.Model),d=[{attr1:1,attr2:2},{attr1:3,attr2:4}],b,c=this.attribute.beforeSet(a,d,b);Y.Assert.isInstanceOf(this.Collection,c,"The return value from beforeSet should have been an instance of the Collection");var f=c.getAt(0),e=c.getAt(1);Y.Assert.areSame(1,f.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(2,f.get("attr2"),"The data should have been converted to a model in the collection");Y.Assert.areSame(3,e.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(4,e.get("attr2"),"The data should have been converted to a model in the collection")},"beforeSet() should convert an array of data objects, when collectionClass is a string":function(){window.__Data_CollectionAttributeTest={};window.__Data_CollectionAttributeTest.ns1={};window.__Data_CollectionAttributeTest.ns1.ns2={};window.__Data_CollectionAttributeTest.ns1.ns2.MyCollection=Data.Collection.extend({model:this.Model});var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.CollectionAttribute({name:"attr",collectionClass:"__Data_CollectionAttributeTest.ns1.ns2.MyCollection"});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,e,b);Y.Assert.isInstanceOf(window.__Data_CollectionAttributeTest.ns1.ns2.MyCollection,d,"The return value from beforeSet should have been an instance of the Collection");var g=d.getAt(0),f=d.getAt(1);Y.Assert.areSame(1,g.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(2,g.get("attr2"),"The data should have been converted to a model in the collection");Y.Assert.areSame(3,f.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(4,f.get("attr2"),"The data should have been converted to a model in the collection")},"beforeSet() should convert an array of data objects, when collectionClass is a function":function(){var f=Data.Collection.extend({model:this.Model});var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.CollectionAttribute({name:"attr",collectionClass:function(){return f}});var e=[{attr1:1,attr2:2},{attr1:3,attr2:4}],d=c.beforeSet(a,e,b);Y.Assert.isInstanceOf(f,d,"The return value from beforeSet should have been an instance of the Collection");var h=d.getAt(0),g=d.getAt(1);Y.Assert.areSame(1,h.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(2,h.get("attr2"),"The data should have been converted to a model in the collection");Y.Assert.areSame(3,g.get("attr1"),"The data should have been converted to a model in the collection");Y.Assert.areSame(4,g.get("attr2"),"The data should have been converted to a model in the collection")},"beforeSet() should return an actual Collection instance unchanged":function(){var a=JsMockito.mock(Data.Model),c,e=new this.Collection([{attr1:1,attr2:2}]),d=this.attribute.beforeSet(a,e,c);Y.Assert.areSame(e,d,"The return value from beforeSet should have been the same collection instance");var b=d.getAt(0);Y.Assert.areSame(1,b.get("attr1"),"The data should remain set to the new model");Y.Assert.areSame(2,b.get("attr2"),"The data should remain set to the new model")},"if no collectionClass was provided, beforeSet() should return an array unchanged":function(){var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.CollectionAttribute({name:"attr"});var e=[{attr1:1,attr2:2}],d=c.beforeSet(a,e,b);Y.Assert.areSame(e,d)}},{name:"Test afterSet()","afterSet() should return the collection (i.e. it doesn't forget the return statement!)":function(){var b=JsMockito.mock(Data.Model),a=JsMockito.mock(Data.Collection);var c=new Data.attribute.CollectionAttribute({name:"attr"});var d=c.afterSet(b,a);Y.Assert.areSame(a,d)}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"DateAttribute",items:[{name:"Test beforeSet()","beforeSet() should return null when provided invalid values":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.DateAttribute({name:"attr",useNull:false}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.isNull(d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.isNull(d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isNull(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isNull(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.isNull(d,"Test with value: 0");d=c.beforeSet(a,1.42,b);Y.Assert.isNull(d,"Test with value: 1.42");d=c.beforeSet(a,"",b);Y.Assert.isNull(d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isNull(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isNull(d,"Test with value: 'true'");d=c.beforeSet(a,{},b);Y.Assert.isNull(d,"Test with value: {}")},"beforeSet() should return a Date object when provided valid values":function(){var a=JsMockito.mock(Data.Model),d=new Data.attribute.DateAttribute({name:"attr",useNull:false}),c,e;e=d.beforeSet(a,"2/22/2012",c);Y.Assert.isInstanceOf(Date,e,"Test with value: '2/22/2012'");var b=new Date("2/22/2012");e=d.beforeSet(a,b,c);Y.Assert.areSame(b,e,"Test with actual Date object")}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"FloatAttribute",items:[{name:"Test getDefaultValue()","getDefaultValue() should return 0 in the default case (i.e. when the `useNull` config is false)":function(){var a=new Data.attribute.FloatAttribute({name:"attr",useNull:false});Y.Assert.areSame(0,a.getDefaultValue())},"getDefaultValue() should return null when the `useNull` config is true":function(){var a=new Data.attribute.FloatAttribute({name:"attr",useNull:true});Y.Assert.isNull(a.getDefaultValue())}},{name:"Test beforeSet()","beforeSet() should return the appropriate string value when provided a range of values and types, when the useNull config is false":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.FloatAttribute({name:"attr",useNull:false}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.areSame(0,d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.areSame(0,d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isNaN(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isNaN(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.areSame(0,d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.areSame(1,d,"Test with value: 1");d=c.beforeSet(a,1.42,b);Y.Assert.areSame(1.42,d,"Test with value: 1.42");d=c.beforeSet(a,"",b);Y.Assert.areSame(0,d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isNaN(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isNaN(d,"Test with value: 'true'");d=c.beforeSet(a,"1",b);Y.Assert.areSame(1,d,"Test with value: '1'");d=c.beforeSet(a,"1.11",b);Y.Assert.areSame(1.11,d,"Test with value: '1.11'");d=c.beforeSet(a,{},b);Y.Assert.isNaN(d,"Test with value: {}")},"beforeSet() should return null for 'unparsable' values/types, when the useNull config is true":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.FloatAttribute({name:"attr",useNull:true}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.isNull(d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.isNull(d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isNaN(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isNaN(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.areSame(0,d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.areSame(1,d,"Test with value: 1");d=c.beforeSet(a,1.42,b);Y.Assert.areSame(1.42,d,"Test with value: 1.42");d=c.beforeSet(a,"",b);Y.Assert.isNull(d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isNaN(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isNaN(d,"Test with value: 'true'");d=c.beforeSet(a,"1",b);Y.Assert.areSame(1,d,"Test with value: '1'");d=c.beforeSet(a,"1.11",b);Y.Assert.areSame(1.11,d,"Test with value: '1.11'");d=c.beforeSet(a,{},b);Y.Assert.isNaN(d,"Test with value: {}")},"beforeSet() should strip off $, %, and comma (',') characters from an input string, to make a float":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.FloatAttribute({name:"attr",useNull:true}),b,d;d=c.beforeSet(a,"$1,000.32%",b);Y.Assert.areSame(1000.32,d,"Test with value: $1,000.32%")}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"IntegerAttribute",items:[{name:"Test getDefaultValue()","getDefaultValue() should return 0 in the default case (i.e. when the `useNull` config is false)":function(){var a=new Data.attribute.IntegerAttribute({name:"attr",useNull:false});Y.Assert.areSame(0,a.getDefaultValue())},"getDefaultValue() should return null when the `useNull` config is true":function(){var a=new Data.attribute.IntegerAttribute({name:"attr",useNull:true});Y.Assert.isNull(a.getDefaultValue())}},{name:"Test beforeSet()","beforeSet() should return the appropriate string value when provided a range of values and types, when the useNull config is false":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.IntegerAttribute({name:"attr",useNull:false}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.areSame(0,d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.areSame(0,d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isNaN(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isNaN(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.areSame(0,d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.areSame(1,d,"Test with value: 1");d=c.beforeSet(a,1.42,b);Y.Assert.areSame(1,d,"Test with value: 1.42");d=c.beforeSet(a,"",b);Y.Assert.areSame(0,d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isNaN(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isNaN(d,"Test with value: 'true'");d=c.beforeSet(a,"1",b);Y.Assert.areSame(1,d,"Test with value: '1'");d=c.beforeSet(a,"1.11",b);Y.Assert.areSame(1,d,"Test with value: '1.11'");d=c.beforeSet(a,{},b);Y.Assert.isNaN(d,"Test with value: {}")},"beforeSet() should return null for 'unparsable' values/types, when the useNull config is true":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.IntegerAttribute({name:"attr",useNull:true}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.isNull(d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.isNull(d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.isNaN(d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.isNaN(d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.areSame(0,d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.areSame(1,d,"Test with value: 1");d=c.beforeSet(a,1.42,b);Y.Assert.areSame(1,d,"Test with value: 1.42");d=c.beforeSet(a,"",b);Y.Assert.isNull(d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.isNaN(d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.isNaN(d,"Test with value: 'true'");d=c.beforeSet(a,"1",b);Y.Assert.areSame(1,d,"Test with value: '1'");d=c.beforeSet(a,"1.11",b);Y.Assert.areSame(1,d,"Test with value: '1.11'");d=c.beforeSet(a,{},b);Y.Assert.isNaN(d,"Test with value: {}")},"beforeSet() should strip off $, %, and comma (',') characters from an input string, to make an integer":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.IntegerAttribute({name:"attr",useNull:true}),b,d;d=c.beforeSet(a,"$1,000.32%",b);Y.Assert.areSame(1000,d,"Test with value: $1,000.32%")}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Data.attribute.ModelAttribute",items:[{name:"Test constructor",_should:{error:{"the constructor should throw an error if the undefined value is provided for the modelClass config, which helps determine when late binding is needed for the modelClass config":"The 'modelClass' config provided to an Attribute with the name 'attr' either doesn't exist, or doesn't exist just yet. Consider using the String or Function form of the modelClass config for late binding, if needed"}},"the constructor should throw an error if the undefined value is provided for the modelClass config, which helps determine when late binding is needed for the modelClass config":function(){var a=new Data.attribute.ModelAttribute({name:"attr",modelClass:undefined});Y.Assert.fail("The constructor should have thrown an error if the modelClass config was provided but was undefined. This is to help with debugging when late binding for the modelClass is needed.")}},{name:"Test valuesAreEqual()",setUp:function(){this.attribute=new Data.attribute.ModelAttribute({name:"attr"})},"valuesAreEqual() should return true for two null values":function(){var a=this.attribute.valuesAreEqual(null,null);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for one null and one object":function(){var a=this.attribute.valuesAreEqual(null,{});Y.Assert.isFalse(a);var a=this.attribute.valuesAreEqual({},null);Y.Assert.isFalse(a)},"valuesAreEqual() should return true for comparing the same model":function(){var c=Data.Model.extend({attributes:["id"]});var d=new c({id:1}),b=new c({id:1});var a=this.attribute.valuesAreEqual(d,b);Y.Assert.isTrue(a)},"valuesAreEqual() should return false for two different models":function(){var c=Data.Model.extend({attributes:["id"]});var d=new c({id:1}),b=new c({id:2});var a=this.attribute.valuesAreEqual(d,b);Y.Assert.isFalse(a)}},{name:"Test beforeSet()",setUp:function(){this.Model=Data.Model.extend({attributes:["attr1","attr2"]});this.attribute=new Data.attribute.ModelAttribute({name:"attr",modelClass:this.Model})},_should:{error:{"beforeSet() should throw an error if the string 'modelClass' config does not reference a Model class":"The string value 'modelClass' config did not resolve to a Model class for attribute 'attr'","beforeSet() should throw an error if the function value 'modelClass' config does not reference a Model class":"The function value 'modelClass' config did not resolve to a Model class for attribute 'attr'"}},"beforeSet() should return null when provided any falsy value, or non-object":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.ModelAttribute({name:"attr"}),b,d;d=c.beforeSet(a,0,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,1,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,"",b);Y.Assert.areSame(null,d);d=c.beforeSet(a,"hi",b);Y.Assert.areSame(null,d);d=c.beforeSet(a,false,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,true,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,undefined,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,null,b);Y.Assert.areSame(null,d)},"beforeSet() should throw an error if the string 'modelClass' config does not reference a Model class":function(){var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.ModelAttribute({name:"attr",modelClass:"somethingThatIsNotDefined"});var e={attr1:1,attr2:2},d=c.beforeSet(a,e,b);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should throw an error if the function value 'modelClass' config does not reference a Model class":function(){var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.ModelAttribute({name:"attr",modelClass:function(){return}});var e={attr1:1,attr2:2},d=c.beforeSet(a,e,b);Y.Assert.fail("The test should have thrown an error in the call to attribute.beforeSet()")},"beforeSet() should convert an anonymous data object to the provided modelClass, when modelClass is a direct reference to the Model subclass":function(){var a=JsMockito.mock(Data.Model),d={attr1:1,attr2:2},b,c=this.attribute.beforeSet(a,d,b);Y.Assert.isInstanceOf(this.Model,c,"The return value from beforeSet should have been an instance of the Model");Y.Assert.areSame(1,c.get("attr1"),"The data should have been set to the new model");Y.Assert.areSame(2,c.get("attr2"),"The data should have been set to the new model")},"beforeSet() should convert an anonymous data object to the provided modelClass, when modelClass is a string":function(){window.__Data_CollectionAttributeTest={};window.__Data_CollectionAttributeTest.ns1={};window.__Data_CollectionAttributeTest.ns1.ns2={};window.__Data_CollectionAttributeTest.ns1.ns2.MyModel=Data.Model.extend({attributes:["attr1","attr2"]});var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.ModelAttribute({name:"attr",modelClass:"__Data_CollectionAttributeTest.ns1.ns2.MyModel"});var e={attr1:1,attr2:2};var d=c.beforeSet(a,e,b);Y.Assert.isInstanceOf(window.__Data_CollectionAttributeTest.ns1.ns2.MyModel,d,"The return value from beforeSet should have been an instance of the Model");Y.Assert.areSame(1,d.get("attr1"),"The data should have been set to the new model");Y.Assert.areSame(2,d.get("attr2"),"The data should have been set to the new model")},"beforeSet() should convert an anonymous data object to the provided modelClass, when modelClass is a function":function(){var c=Data.Model.extend({attributes:["attr1","attr2"]});var a=JsMockito.mock(Data.Model),b;var d=new Data.attribute.ModelAttribute({name:"attr",modelClass:function(){return c}});var f={attr1:1,attr2:2};var e=d.beforeSet(a,f,b);Y.Assert.isInstanceOf(c,e,"The return value from beforeSet should have been an instance of the Model");Y.Assert.areSame(1,e.get("attr1"),"The data should have been set to the new model");Y.Assert.areSame(2,e.get("attr2"),"The data should have been set to the new model")},"beforeSet() should return an actual Model instance unchanged":function(){var a=JsMockito.mock(Data.Model),b,d=new this.Model({attr1:1,attr2:2}),c=this.attribute.beforeSet(a,d,b);Y.Assert.areSame(d,c,"The return value from beforeSet should have been the same model instance");Y.Assert.areSame(1,c.get("attr1"),"The data should remain set to the new model");Y.Assert.areSame(2,c.get("attr2"),"The data should remain set to the new model")},"if no modelClass was provided, beforeSet() should return an anonymous data object unchanged":function(){var a=JsMockito.mock(Data.Model),b;var c=new Data.attribute.ModelAttribute({name:"attr"});var e={attr1:1,attr2:2};var d=c.beforeSet(a,e,b);Y.Assert.areSame(e,d)}},{name:"Test afterSet()","afterSet() should return the model (i.e. it doesn't forget the return statement!)":function(){var a=JsMockito.mock(Data.Model);var b=new Data.attribute.ModelAttribute({name:"attr"});var c=b.afterSet(a,a);Y.Assert.areSame(a,c)}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"Data.attribute.ObjectAttribute",items:[{name:"Test the defaultValue","The default defaultValue for ObjectAttribute should be null":function(){Y.Assert.isNull(Data.attribute.ObjectAttribute.prototype.defaultValue)}},{name:"Test beforeSet()","beforeSet() should return null when provided any falsy value, or non-object":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.ObjectAttribute({name:"attr"}),b,d;d=c.beforeSet(a,0,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,1,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,"",b);Y.Assert.areSame(null,d);d=c.beforeSet(a,"hi",b);Y.Assert.areSame(null,d);d=c.beforeSet(a,false,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,true,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,undefined,b);Y.Assert.areSame(null,d);d=c.beforeSet(a,null,b);Y.Assert.areSame(null,d)},"beforeSet() should return an object unchanged":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.ObjectAttribute({name:"attr"}),b;var e={attr1:1,attr2:2};var d=c.beforeSet(a,e,b);Y.Assert.areSame(e,d)}}]}));tests.unit.attribute.add(new Ext.test.TestSuite({name:"StringAttribute",items:[{name:"Test getDefaultValue()","getDefaultValue() should return an empty string in the default case (i.e. when the `useNull` config is false)":function(){var a=new Data.attribute.StringAttribute({name:"attr",useNull:false});Y.Assert.areSame("",a.getDefaultValue())},"getDefaultValue() should return null when the `useNull` config is true":function(){var a=new Data.attribute.StringAttribute({name:"attr",useNull:true});Y.Assert.isNull(a.getDefaultValue())}},{name:"Test beforeSet()","beforeSet() should return the appropriate string value when provided a range of values and types, when the useNull config is false":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.StringAttribute({name:"attr",useNull:false}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.areSame("",d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.areSame("",d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.areSame("false",d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.areSame("true",d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.areSame("0",d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.areSame("1",d,"Test with value: 1");d=c.beforeSet(a,"",b);Y.Assert.areSame("",d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.areSame("hi",d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.areSame("true",d,"Test with value: 'true'");d=c.beforeSet(a,{},b);Y.Assert.areSame("[object Object]",d,"Test with value: {}")},"beforeSet() should return null for 'unparsable' values/types, when the useNull config is true":function(){var a=JsMockito.mock(Data.Model),c=new Data.attribute.StringAttribute({name:"attr",useNull:true}),b,d;d=c.beforeSet(a,undefined,b);Y.Assert.isNull(d,"Test with value: undefined");d=c.beforeSet(a,null,b);Y.Assert.isNull(d,"Test with value: null");d=c.beforeSet(a,false,b);Y.Assert.areSame("false",d,"Test with value: false");d=c.beforeSet(a,true,b);Y.Assert.areSame("true",d,"Test with value: true");d=c.beforeSet(a,0,b);Y.Assert.areSame("0",d,"Test with value: 0");d=c.beforeSet(a,1,b);Y.Assert.areSame("1",d,"Test with value: 1");d=c.beforeSet(a,"",b);Y.Assert.areSame("",d,"Test with value: ''");d=c.beforeSet(a,"hi",b);Y.Assert.areSame("hi",d,"Test with value: 'hi'");d=c.beforeSet(a,"true",b);Y.Assert.areSame("true",d,"Test with value: 'true'");d=c.beforeSet(a,{},b);Y.Assert.areSame("[object Object]",d,"Test with value: {}")}}]}));tests.unit.add(new Ext.test.TestSuite({name:"Data.Collection",items:[{name:"Test the constructor",setUp:function(){this.Model=Data.Model.extend({attributes:["attr"]});this.Collection=Data.Collection.extend({model:this.Model})},"The constructor should accept a configuration object to initialize the Collection with an initial set of models and any other custom configs":function(){var a=new this.Model({attr:"value1"});var b=new this.Collection({models:a,customConfig:1});var c=b.getModels();Y.Assert.areSame(1,c.length,"There should now be one model in the collection");Y.Assert.areSame(a,c[0],"The model in the collection should be the one provided to the 'models' config");Y.Assert.areSame(1,b.customConfig,"The customConfig should have been applied to the collection")},"The constructor should accept an array of Models to initialize the Collection with":function(){var d=new this.Model({attr:"value1"}),b=new this.Model({attr:"value2"}),a=new this.Collection([d,b]);var c=a.getModels();Y.Assert.areSame(2,c.length,"There should now be two models in the collection");Y.Assert.areSame(d,c[0],"The first model should be the first model provided to the constructor");Y.Assert.areSame(b,c[1],"The second model should be the second model provided to the constructor")}},{name:"Test createModel()","createModel() should take an anonymous config object, and transform it into a Model instance, based on the 'model' config":function(){var d=Data.Model.extend({attributes:["attr"]});var b=Data.Collection.extend({model:d});var c=new b();var a=c.createModel({attr:"testValue"});Y.Assert.isInstanceOf(d,a);Y.Assert.areSame("testValue",a.get("attr"))}},{name:"Test add()","add() should simply delegate to the insert() method":function(){var f=Data.Model.extend({attributes:["attr"]});var c,b;var a=Data.Collection.extend({model:f,insert:function(i,h){c=i;b=h}});var e=new a(),g=new f(),d=new f();e.add([g,d]);Y.ArrayAssert.itemsAreSame([g,d],c,"The models passed to insert() should be the same ones provided to add()");Y.Assert.isUndefined(b,"The index for the insert should be undefined, which defaults to appending the models to the collection")}},{name:"Test insert()",setUp:function(){this.Model=Data.Model.extend({attributes:["attr"]});this.Collection=Data.Collection.extend({model:this.Model})},"insert() should be able to add a single Model instance to the Collection":function(){var b=new this.Collection(),a=new this.Model({attr:"value"}),c;c=b.getModels();Y.Assert.areSame(0,c.length,"Initial condition: There should be no models in the collection");b.insert(a);c=b.getModels();Y.Assert.areSame(1,c.length,"There should now be one model in the collection");Y.Assert.areSame(a,c[0],"The model added should be the first model in the collection")},"insert() should be able to add an array of Model instances to the Collection":function(){var b=new this.Collection(),d=new this.Model({attr:"value1"}),a=new this.Model({attr:"value2"}),c;c=b.getModels();Y.Assert.areSame(0,c.length,"Initial condition: There should be no models in the collection");b.insert([d,a]);c=b.getModels();Y.Assert.areSame(2,c.length,"There should now be two models in the collection");Y.Assert.areSame(d,c[0],"The first model added in the array should be the first model in the collection");Y.Assert.areSame(a,c[1],"The second model added in the array should be the second model in the collection")},"inserting (adding) one or more models should have the Collection considered as 'modified'":function(){var b=new this.Collection(),d=new this.Model({attr:"value1"}),a=new this.Model({attr:"value2"}),c;Y.Assert.isFalse(b.isModified(),"Initial condition: the collection should not be modified");b.add(d);Y.Assert.isTrue(b.isModified(),"The collection should now be considered modified")},"insert() should be able to add a single Model instance to the Collection at a specified index":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c]),d;d=b.getModels();Y.Assert.areSame(2,d.length,"Initial condition: There should be 2 models in the collection");b.insert(a,1);d=b.getModels();Y.Assert.areSame(3,d.length,"There should now be 3 models in the collection");Y.ArrayAssert.itemsAreSame([e,a,c],d,"model3 should have been added in the middle")},"insert() should be able to add an array of Model instance to the Collection at a specified index":function(){var f=new this.Model({attr:"value1"}),d=new this.Model({attr:"value2"}),b=new this.Model({attr:"value3"}),a=new this.Model({attr:"value4"}),c=new this.Collection([f,d]),e;e=c.getModels();Y.Assert.areSame(2,e.length,"Initial condition: There should be 2 models in the collection");c.insert([b,a],1);e=c.getModels();Y.Assert.areSame(4,e.length,"There should now be 4 models in the collection");Y.ArrayAssert.itemsAreSame([f,b,a,d],e,"model3 and model4 should have been added in the middle")},"insert() should fire the 'add' event for a single inserted model":function(){var d=new this.Collection(),a=new this.Model({attr:"value"}),e;var b=0,c;d.on("add",function(g,f){b++;c=f});d.insert(a);Y.Assert.areSame(1,b,"The 'add' event should have been fired exactly once");Y.Assert.areSame(a,c,"The model provided with the 'add' event should be the model added to the collection")},"insert() should fire the 'add' event one time for each of multiple inserted models":function(){var d=new this.Collection(),f=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),e;var a=0,b=[];d.on("add",function(h,g){a++;b.push(g)});d.insert([f,c]);Y.Assert.areSame(2,a,"The 'add' event should have been fired exactly twice");Y.Assert.areSame(f,b[0],"The first model added should be the first model added to the collection");Y.Assert.areSame(c,b[1],"The second model added should be the second model added to the collection")},"insert() should *not* fire the 'add' event for a model that is already in the Collection":function(){var a=new this.Model({attr:"value1"}),c=new this.Collection([a]);var b=false;c.on("add",function(e,d){b=true});c.insert(a);Y.Assert.isFalse(b,"The 'add' event should not have been fired for another insert of the same model")},"insert() should *not* fire the 'add' event for models that are already in the Collection when multiple models are inserted, and only some exist already":function(){var e=new this.Model({attr:"value1"}),d=new this.Model({attr:"value2"}),c=new this.Collection([e]);var a=0,b=[];c.on("add",function(g,f){a++;b.push(f)});c.insert([e,d]);Y.Assert.areSame(1,a,"The 'add' event should have been fired exactly once");Y.ArrayAssert.itemsAreSame([d],b,"The 'add' event should have only fired with the model that was actually added")},"insert() should fire the 'addset' event with the array of inserted models, even if only one model is inserted":function(){var c=new this.Collection(),a=new this.Model({attr:"value"}),d;var b;c.on("addset",function(e,f){b=f});c.insert(a);Y.Assert.areSame(1,b.length,"1 model should have been provided to the 'addset' event");Y.Assert.areSame(a,b[0],"The model provided with the 'addset' event should be the model added to the collection")},"insert() should fire the 'addset' event with the array of inserted models when multiple models are inserted":function(){var c=new this.Collection(),e=new this.Model({attr:"value1"}),b=new this.Model({attr:"value2"}),d;var a;c.on("addset",function(f,g){a=g});c.insert([e,b]);Y.Assert.areSame(2,a.length,"2 models should have been provided to the 'addset' event");Y.Assert.areSame(e,a[0],"The first model added in the array should be the first model added to the collection");Y.Assert.areSame(b,a[1],"The second model added in the array should be the second model added to the collection")},"insert() should *not* fire the 'addset' event for a model that is already in the Collection":function(){var a=new this.Model({attr:"value1"}),c=new this.Collection([a]);var b=false;c.on("addset",function(d,e){b=true});c.insert(a);Y.Assert.isFalse(b,"The 'addset' event should not have been fired for another insert of the same model")},"insert() should *not* fire the 'addset' event for models that are already in the Collection when multiple models are inserted, and only some exist already":function(){var d=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),b=new this.Collection([d]);var a;b.on("addset",function(e,f){a=f});b.insert([d,c]);Y.ArrayAssert.itemsAreSame([c],a,"The 'addset' event should have only fired with the model that was actually added")},"insert() should reorder models when they already exist in the Collection":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c,a]),d;b.insert(a,0);Y.ArrayAssert.itemsAreSame([a,e,c],b.getModels(),"insert() should have moved model3 to the beginning");b.insert([c,e],0);Y.ArrayAssert.itemsAreSame([c,e,a],b.getModels(),"insert() should have moved model2 and model1 to the beginning");b.insert(c,2);Y.ArrayAssert.itemsAreSame([e,a,c],b.getModels(),"insert() should have moved model2 to the end");b.insert(c,-1000);Y.ArrayAssert.itemsAreSame([c,e,a],b.getModels(),"insert() should have moved model2 to the beginning with an out of bounds negative index");b.insert([e,c],1000);Y.ArrayAssert.itemsAreSame([a,e,c],b.getModels(),"insert() should have moved model1 and model2 to the end with an out of bounds positive index")},"insert() should fire the 'reorder' event when reordering models":function(){var h=new this.Model({attr:"value1"}),g=new this.Model({attr:"value2"}),f=new this.Model({attr:"value3"}),b=new this.Collection([h,g,f]),a;var i=0,c=[],e=[],d=[];b.on("reorder",function(l,j,k,m){i++;c.push(j);e.push(k);d.push(m)});b.insert(f,0);Y.ArrayAssert.itemsAreSame([f,h,g],b.getModels(),"The models should be in the correct new order (this is mostly here to just show which order the collection should now be in)");Y.Assert.areSame(1,i,"The reorder event should have been fired exactly once");Y.ArrayAssert.itemsAreSame([f],c,"model3 should have been fired with a 'reorder' event (and that is the only reorder event that should have been fired)");Y.ArrayAssert.itemsAreSame([0],e,"the new index for model3 should have been reported as index 0");Y.ArrayAssert.itemsAreSame([2],d,"the old index for model3 should have been reported as index 2");i=0;c=[];e=[];d=[];b.insert([h,g],0);Y.ArrayAssert.itemsAreSame([h,g,f],b.getModels(),"The models should be in the correct new order (this is mostly here to just show which order the collection should now be in)");Y.Assert.areSame(2,i,"The reorder event should have been fired exactly twice");Y.ArrayAssert.itemsAreSame([h,g],c,"model1 and model2 should have been fired with a 'reorder' events");Y.ArrayAssert.itemsAreSame([0,1],e,"the new indexes for model1 and model2 should have been reported as index 0, and 1, respectively");Y.ArrayAssert.itemsAreSame([1,2],d,"the old indexes for model1 and model2 should have been reported as index 1, and 2, respectively")},"in a 'reorder' event handler, the new order of the models should be present immediately (getModels should return the models in the new order, inside a handler)":function(){var f=new this.Model({attr:"value1"}),d=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),c=new this.Collection([f,d,a]),e;var b;c.on("reorder",function(i,g,h,j){b=i.getModels()});c.insert(a,1);Y.ArrayAssert.itemsAreSame([f,a,d],b);c.insert(f,1);Y.ArrayAssert.itemsAreSame([a,f,d],b)},"After a reorder, the Collection should be considered 'modified'":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c,a]),d;Y.Assert.isFalse(b.isModified(),"Initial condition: the collection should not yet be considered 'modified'");b.insert(a,1);Y.Assert.isTrue(b.isModified(),"The collection should now be considered modified, since there has been a reorder")},"insert() should *not* reorder models when calling insert() without the `index` argument (which would be the case as well if add() was called)":function(){var e=new this.Model({attr:"value1"}),c=new this.Model({attr:"value2"}),a=new this.Model({attr:"value3"}),b=new this.Collection([e,c,a]),d;b.insert(e);Y.ArrayAssert.itemsAreSame([e,c,a],b.getModels(),"The models should be in the original order, as the supposed 'append' should not have happened because the model was already in the collection, and no new index was given")},"insert() should transform anonymous data objects to Model instances, based on the 'model' config":function(){var c=new this.Collection(),b={attr:"value1"},a={attr:"value2"},d;d=c.getModels();Y.Assert.areSame(0,d.length,"Initial condition: There should be no models in the collection");c.insert([b,a]);d=c.getModels();Y.Assert.areSame(2,d.length,"There should now be two models in the collection");Y.Assert.areSame("value1",d[0].get("attr"),"The first model added in the array should have the data provided from modelData1");Y.Assert.areSame("value2",d[1].get("attr"),"The second model added in the array should have the data provided from modelData2")},"insert() should fire the 'addset' event with instantiated models for any anonymous config objects":function(){var d=new this.Collection(),c={attr:"value1"},b={attr:"value2"};var a;d.on("addset",function(e,f){a=f});d.insert([c,b]);Y.Assert.areSame(2,a.length,"2 models should have been provided to the 'addset' event");Y.Assert.areSame("value1",a[0].get("attr"),"The first model added in the array should have the data provided from modelData1");Y.Assert.areSame("value2",a[1].get("attr"),"The second model added in the array should have the data provided from modelData2")},"insert() should insert models in the order specified by the sortBy config, if one is provided":function(){var f=Data.Model.extend({attributes:["name"]});var a=Data.Collection.extend({sortBy:function(l,k){var j=l.get("name"),i=k.get("name");return(j<i)?-1:(j>i)?1:0}});var h=new f({name:"A"}),e=new f({name:"B"}),b=new f({name:"D"}),g;var d=new a();d.insert([e,b,h]);g=d.getModels();Y.ArrayAssert.itemsAreSame([h,e,b],g,"The models should have been re-ordered based on the 'name' attribute");var c=new f({name:"C"});d.insert(c);g=d.getModels();Y.ArrayAssert.itemsAreSame([h,e,c,b],g,"The models should have been re-ordered based on the 'name' attribute with the new model")},"the sortBy() function should be called in the scope of the Collection":function(){var a="";var f=Data.Model.extend({attributes:["name"]});var b=Data.Collection.extend({getAttributeNameToSortBy:function(){return"name"},sortBy:function(i,h){a=this.getAttributeNameToSortBy();return 0}});var g=new f({name:"A"}),e=new f({name:"B"}),c=new f({name:"C"});var d=new b();d.insert([e,c,g]);Y.Assert.areSame("name",a,"The attributeNameToSortBy variable should have been set by sortBy() being called in the correct scope, able to access its helper method")},"insert() should not allow duplicate models (at this time. config option to come)":function(){var a=new this.Model(),b=new this.Collection();b.insert([a,a]);Y.ArrayAssert.itemsAreSame([a],b.getModels(),"There should only be the one model in the collection at this time")},"insert() should attach a 'change' listener for changes to the 'idAttribute' of a model, so that its internal modelsById hashmap can be updated if it changes":function(){var d=0,g,a;var f=Data.Model.extend({attributes:["id"],idAttribute:"id"});var c=Data.Collection.extend({onModelIdChange:function(i,j,h){d++;g=j;a=h;this._super(arguments)}});var b=new f();var e=new c([b]);b.set("id",1);Y.Assert.areSame(1,d,"The onModelIdChange method should have been called exactly once");Y.Assert.areSame(1,g,"The newIdValue should be 1");Y.Assert.isUndefined(a,"The oldIdValue should be undefined");Y.Assert.areSame(b,e.getById(1),"The model should have been able to be retrieved by its ID");b.set("id",2);Y.Assert.areSame(2,d,"The onModelIdChange method should have been called exactly twice at this point");Y.Assert.areSame(2,g,"The newIdValue should be 2");Y.Assert.areSame(1,a,"The oldIdValue should be 1");Y.Assert.isNull(e.getById(1),"The model should no longer be retrievable by its old ID");Y.Assert.areSame(b,e.getById(2),"The model should now be retrievable by its new ID")}},{name:"Test remove()",setUp:function(){this.Model=Data.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Data.Collection.extend({model:this.Model})},"remove() should be able to remove a single Model from the Collection":function(){var f=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),d=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),b=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"}),a=new this.Model({boolAttr:true,numberAttr:3,stringAttr:"value3"});var c=new this.Collection([f,d,b,a]),e;e=c.getModels();Y.ArrayAssert.itemsAreSame([f,d,b,a],e,"Initial condition: the Collection should have 4 models");c.remove(d);e=c.getModels();Y.ArrayAssert.doesNotContain(d,e,"model2 should no longer exist in the Collection");Y.ArrayAssert.itemsAreSame([f,b,a],e,"The remaining 3 models should all exist, and be in the correct order");c.remove(a);e=c.getModels();Y.ArrayAssert.doesNotContain(a,e,"model4 should no longer exist in the Collection");Y.ArrayAssert.itemsAreSame([f,b],e,"The remaining 2 models should all exist, and be in the correct order");c.remove(f);e=c.getModels();Y.ArrayAssert.doesNotContain(f,e,"model1 should no longer exist in the Collection");Y.ArrayAssert.itemsAreSame([b],e,"The remaining model should exist");c.remove(b);e=c.getModels();Y.ArrayAssert.isEmpty(e,"There should be no more models left")},"remove() should be able to remove an array of Models from the Collection":function(){var f=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),d=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),b=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"}),a=new this.Model({boolAttr:true,numberAttr:3,stringAttr:"value3"});var c=new this.Collection([f,d,b,a]),e;e=c.getModels();Y.ArrayAssert.itemsAreSame([f,d,b,a],e,"Initial condition: the Collection should have 4 models");c.remove([d,a]);e=c.getModels();Y.ArrayAssert.itemsAreSame([f,b],e,"Only model1 and model3 should remain")},"remove() should fire the 'remove' event for a single model that is removed":function(){var f=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),d=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var c=new this.Collection([f,d]);var e=0,b,a;c.on("remove",function(i,h,g){e++;b=h;a=g});c.remove(d);Y.Assert.areSame(1,e,"The 'remove' event should have been fired exactly once");Y.Assert.areSame(d,b,"The removed model should have been model2");Y.Assert.areSame(1,a,"model2 should have been removed from index 1")},"remove() should fire the 'remove' event once for each of the removed models when multiple models are removed":function(){var f=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),d=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var c=new this.Collection([f,d]);var e=0,a=[],b=[];c.on("remove",function(i,h,g){e++;a.push(h);b.push(g)});c.remove([f,d]);Y.Assert.areSame(2,e,"The 'remove' event should have been fired exactly twice");Y.ArrayAssert.itemsAreSame([f,d],a,"model1 and model2 should have been removed");Y.ArrayAssert.itemsAreSame([0,0],b,"The indexes for each model's removal should have both been 0, as after the first one is removed (at index 0), model2 is moved to index 0, and then removed itself")},"remove() should *not* fire the 'remove' event if no models are actually removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d]);var a=false;b.on("removeset",function(e,f){a=true});b.remove(c);Y.Assert.isFalse(a,"The 'remove' event should not have been called")},"remove() should fire the 'removeset' event with the array of removed models, even if only one model has been removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d,c]);var a;b.on("removeset",function(e,f){a=f});b.remove(c);Y.ArrayAssert.itemsAreSame([c],a)},"remove() should fire the 'removeset' event with the array of removed models when multiple models are removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d,c]);var a;b.on("removeset",function(e,f){a=f});b.remove([d,c]);Y.ArrayAssert.itemsAreSame([d,c],a)},"remove() should *not* fire the 'removeset' event if no models are actually removed":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var b=new this.Collection([d]);var a=0;b.on("removeset",function(e,f){a++});b.remove(c);Y.Assert.areSame(0,a)},"remove() should remove the model from the modelsById hashmap, so it is no longer retrievable by getById":function(){var c=Data.Model.extend({attributes:["id"],idAttribute:"id"});var a=new c({id:1});var b=new Data.Collection([a]);Y.Assert.areSame(a,b.getById(1),"Initial condition: the model should be available to getById()");b.remove(a);Y.Assert.isNull(b.getById(1),"The model should no longer be retrievable by getById() after removal")},"remove() should remove the model from the modelsByClientId hashmap, so it is no longer retrievable by getById":function(){var d=Data.Model.extend({}),a=new d(),b=a.getClientId(),c=new Data.Collection([a]);Y.Assert.areSame(a,c.getByClientId(b),"Initial condition: the model should be available to getByClientId()");c.remove(a);Y.Assert.isNull(c.getByClientId(b),"The model should no longer be retrievable by getByClientId() after removal")},"remove() should remove the 'change' listener for changes to the 'idAttribute' of a model, so that its internal modelsById hashmap can be updated if it changes":function(){var d=0,g,a;var f=Data.Model.extend({attributes:["id"],idAttribute:"id"});var c=Data.Collection.extend({onModelIdChange:function(i,j,h){d++;g=j;a=h;this._super(arguments)}});var b=new f();var e=new c([b]);b.set("id",1);Y.Assert.areSame(1,d,"The onModelIdChange method should have been called exactly once");Y.Assert.areSame(1,g,"The newIdValue should be 1");Y.Assert.isUndefined(a,"The oldIdValue should be undefined");Y.Assert.areSame(b,e.getById(1),"The model should have been able to be retrieved by its ID");e.remove(b);b.set("id",2);Y.Assert.areSame(1,d,"The onModelIdChange method should *not* have been called again at this point")}},{name:"Test removeAll()",setUp:function(){this.Model=Data.Model.extend({attributes:["id"],idAttribute:"id"});this.Collection=Data.Collection.extend({model:this.Model})},"removeAll() should be able to remove all Models from the Collection":function(){var f=new this.Model(),d=new this.Model(),b=new this.Model(),a=new this.Model();var c=new this.Collection([f,d,b,a]),e;e=c.getModels();Y.ArrayAssert.itemsAreSame([f,d,b,a],e,"Initial condition: the Collection should have 4 models");c.removeAll();e=c.getModels();Y.ArrayAssert.isEmpty(e,"There should be no models left in the collection")},"removeAll() should fire the 'remove' event for each of the removed models":function(){var f=new this.Model(),e=new this.Model(),c=new this.Model(),b=new this.Model();var d=new this.Collection([f,e,c,b]);var a=[];d.on("remove",function(h,g){a.push(g)});d.removeAll();Y.ArrayAssert.itemsAreSame([f,e,c,b],a)},"removeAll() should fire the 'removeset' event with the array of removed models when multiple models are removed":function(){var f=new this.Model(),e=new this.Model(),c=new this.Model(),b=new this.Model();var d=new this.Collection([f,e,c,b]);var a;d.on("removeset",function(g,h){a=h});d.removeAll();Y.ArrayAssert.itemsAreSame([f,e,c,b],a)},"removeAll() should *not* fire the 'removeset' event if no models are actually removed":function(){var b=new this.Collection();var a=0;b.on("removeset",function(c,d){a++});b.removeAll();Y.Assert.areSame(0,a)},"removeAll() should clear the `modelsByClientId` and `modelsById` hashmaps":function(){var c=new this.Model({id:1}),b=new this.Model({id:2});var a=new this.Collection([c,b]);Y.Assert.areSame(c,a.getByClientId(c.getClientId()),"Initial condition: should be able to retrieve model1 by clientId");Y.Assert.areSame(c,a.getById(c.getId()),"Initial condition: should be able to retrieve model1 by id");Y.Assert.areSame(b,a.getByClientId(b.getClientId()),"Initial condition: should be able to retrieve model2 by clientId");Y.Assert.areSame(b,a.getById(b.getId()),"Initial condition: should be able to retrieve model2 by id");a.removeAll();Y.Assert.isNull(a.getByClientId(c.getClientId()),"should no longer be able to retrieve model1 by clientId");Y.Assert.isNull(a.getById(c.getId()),"should no longer be able to retrieve model1 by id");Y.Assert.isNull(a.getByClientId(b.getClientId()),"should no longer be able to retrieve model2 by clientId");Y.Assert.isNull(a.getById(b.getId()),"should no longer be able to retrieve model2 by id")}},{name:"Test getAt()",setUp:function(){this.Model=Data.Model.extend({attributes:["id"],idAttribute:"id"});this.Collection=Data.Collection.extend({model:this.Model})},"getAt() should return the model at a given index":function(){var c=new this.Model(),b=new this.Model();var a=new this.Collection([c,b]);Y.Assert.areSame(c,a.getAt(0),"model1 should be at index 0");Y.Assert.areSame(b,a.getAt(1),"model2 should be at index 1")},"getAt() should return null for an index that is out of bounds":function(){var c=new this.Model(),b=new this.Model();var a=new this.Collection([c,b]);Y.Assert.isNull(a.getAt(-1),"Should be null for a negative index");Y.Assert.isNull(a.getAt(2),"Should be null for an index greater than the number of models")}},{name:"Test getFirst()",setUp:function(){this.Model=Data.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Data.Collection.extend({model:this.Model})},"getFirst() should retrieve the first Model in the Collection":function(){var c=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),b=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Collection([c,b]);Y.Assert.areSame(c,a.getFirst())},"getFirst() should return null if there are no models in the Collection":function(){var a=new this.Collection();Y.Assert.isNull(a.getFirst())}},{name:"Test getLast()",setUp:function(){this.Model=Data.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Data.Collection.extend({model:this.Model})},"getLast() should retrieve the first Model in the Collection":function(){var c=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),b=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Collection([c,b]);Y.Assert.areSame(b,a.getLast())},"getLast() should return null if there are no models in the Collection":function(){var a=new this.Collection();Y.Assert.isNull(a.getLast())}},{name:"Test getRange()",setUp:function(){this.Model=Data.Model.extend({attributes:["attr"]});this.Collection=Data.Collection.extend({model:this.Model})},"getRange() should retrieve all models when no arguments are provided":function(){var e=new this.Model(),c=new this.Model(),a=new this.Model();var b=new this.Collection([e,c,a]),d=b.getRange();Y.ArrayAssert.itemsAreSame([e,c,a],d)},"getRange() should retrieve models based on just the startIndex argument, defaulting endIndex to the last model in the Collection":function(){var e=new this.Model(),c=new this.Model(),a=new this.Model();var b=new this.Collection([e,c,a]),d;d=b.getRange(0);Y.ArrayAssert.itemsAreSame([e,c,a],d,"All models should have been retrieved");d=b.getRange(1);Y.ArrayAssert.itemsAreSame([c,a],d,"The second and third models should have been retrieved");d=b.getRange(2);Y.ArrayAssert.itemsAreSame([a],d,"The third model should have been retrieved");d=b.getRange(3);Y.ArrayAssert.isEmpty(d,"No models should have been retrieved")},"getRange() should retrieve models based on the startIndex and endIndex arguments":function(){var e=new this.Model(),c=new this.Model(),a=new this.Model();var b=new this.Collection([e,c,a]),d;d=b.getRange(0,0);Y.ArrayAssert.itemsAreSame([e],d,"0, 0 args did not work correctly. First model should have been retrieved");d=b.getRange(0,1);Y.ArrayAssert.itemsAreSame([e,c],d,"0, 1 args did not work correctly. First and second model should have been retrieved");d=b.getRange(1,1);Y.ArrayAssert.itemsAreSame([c],d,"1, 1 args did not work correctly. Second model should have been retrieved");d=b.getRange(1,2);Y.ArrayAssert.itemsAreSame([c,a],d,"1, 2 args did not work correctly. Second and third models should have been retrieved");d=b.getRange(0,2);Y.ArrayAssert.itemsAreSame([e,c,a],d,"0, 2 args did not work correctly. Second and third models should have been retrieved");d=b.getRange(-10000,10000);Y.ArrayAssert.itemsAreSame([e,c,a],d,"Out of range -10000, 10000 args did not work correctly. All models should have been retrieved")}},{name:"Test getModels()","getModels() should return the array of models, but in a new array so that the array can be changed":function(){var e=Data.Model.extend({attributes:["attr"]}),f=new e({attr:1}),d=new e({attr:2}),b=new e({attr:3}),c=new Data.Collection([f,d,b]);var a=c.getModels();a.splice(0,1);Y.Assert.areSame(2,a.length,"The models array should have been reduced to 2 elements");Y.Assert.areSame(3,c.getCount(),"The number of models in the collection should still be 3")}},{name:"Test getData()",setUp:function(){this.origNativeObjectConverter=Data.data.NativeObjectConverter;var a=this.args={};Data.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}}},tearDown:function(){Data.data.NativeObjectConverter=this.origNativeObjectConverter},"getData() should delegate to the singleton NativeObjectConverter to create an Array representation of its data":function(){var e=Data.Model.extend({attributes:["attr1","attr2"]});var c=Data.Collection.extend({model:e});var d=new c([{attr1:"value1",attr2:"value2"}]);var b={raw:true};var a=d.getData(b);Y.Assert.areSame(d,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the collection.");Y.Assert.areSame(b,this.args[1],"The second arg provided to NativeObjectConverter::convert() should have been the options object")}},{name:"Test getCount()","getCount() should return 0 for a brand new Collection":function(){var a=new Data.Collection();Y.Assert.areSame(0,a.getCount())},"getCount() should return the number of models inserted at any given time":function(){var d=Data.Model.extend({attributes:["attr"]}),e=new d({attr:1}),c=new d({attr:2}),a=new d({attr:3}),b=new Data.Collection([e,c]);Y.Assert.areSame(2,b.getCount(),"initially, the collection should have 2 models");b.remove(e);Y.Assert.areSame(1,b.getCount(),"After removal of model1, the collection should have 1 model");b.add([e,a]);Y.Assert.areSame(3,b.getCount(),"After adding model1 and model3, the collection should have 3 models")}},{name:"Test getByClientId()","getByClientId() should retrieve a model by its clientId":function(){var c=Data.Model.extend({}),d=new c(),b=new c();var a=new Data.Collection([d,b]);Y.Assert.areSame(d,a.getByClientId(d.getClientId()),"model1 should have been able to be retrieved by its clientId");Y.Assert.areSame(b,a.getByClientId(b.getClientId()),"model2 should have been able to be retrieved by its clientId")},"getByClientId() should return null if the collection doesn't have the model whose clientId is requested":function(){var c=Data.Model.extend({}),a=new c();var b=new Data.Collection();Y.Assert.isNull(b.getByClientId(a.getClientId()))}},{name:"Test getById()",setUp:function(){this.Model=Data.Model.extend({attributes:["id"],idAttribute:"id"})},"getById() should retrieve a model by its id attribute":function(){var c=new this.Model({id:1}),b=new this.Model({id:2});var a=new Data.Collection([c,b]);Y.Assert.areSame(c,a.getById(1),"model1 should have been able to be retrieved by its id");Y.Assert.areSame(b,a.getById(2),"model2 should have been able to be retrieved by its id")},"getById() should return null for a model id that doesn't exist within its collection":function(){var c=new this.Model({id:1}),b=new this.Model({id:2});var a=new Data.Collection();Y.Assert.isNull(a.getById(1),"Test with no models in the collection at all");a.add(c);Y.Assert.isNull(a.getById(2),"Test with a model in the collection");Y.Assert.areSame(c,a.getById(1),"Sanity check, model1 should be able to be retrieved by its id at this point")},"getById() should retreive a model by its id attribute, even if it doesn't yet have an id when it is added to the collection (the id is added later)":function(){var a=new this.Model(),b=new Data.Collection([a]);a.set("id",1);Y.Assert.areSame(a,b.getById(1))}},{name:"Test has()","has() should return true if a model has been added to the collection, and false if a model has not been added to the collection":function(){var c=Data.Model.extend({attributes:["attr"]});var d=new c(),b=new c(),a=new Data.Collection();Y.Assert.isFalse(a.has(d),"Initial condition: the collection should not have model1");Y.Assert.isFalse(a.has(b),"Initial condition: the collection should not have model2");a.add(d);Y.Assert.isTrue(a.has(d),"The collection should now have model1");Y.Assert.isFalse(a.has(b),"The collection should still not have model2, as it has not been added");a.remove(d);Y.Assert.isFalse(a.has(d),"The collection should not have model1 anymore, as it has been removed")}},{name:"Test indexOf()","indexOf() should return the index of a model in the collection":function(){var c=Data.Model.extend({attributes:["attr"]}),d=new c(),b=new c(),a=new Data.Collection([d,b]);Y.Assert.areSame(0,a.indexOf(d),"model1 should be at index 0");Y.Assert.areSame(1,a.indexOf(b),"model2 should be at index 1")},"indexOf() should return -1 for a model that does not exist within the collection":function(){var c=Data.Model.extend({attributes:["attr"]}),d=new c(),b=new c(),a=new Data.Collection([d]);Y.Assert.areSame(-1,a.indexOf(b),"model2 is not in the collection, so indexOf() should return -1")}},{name:"Test indexOfId()","indexOfId() should return the index of a model by its id in the collection":function(){var c=Data.Model.extend({attributes:["id"],idAttribute:"id"}),d=new c({id:1}),b=new c({id:2}),a=new Data.Collection([d,b]);Y.Assert.areSame(0,a.indexOfId(1),"model1 should be at index 0");Y.Assert.areSame(1,a.indexOfId(2),"model2 should be at index 1")},"indexOfId() should return -1 for a model by its id that does not exist within the collection":function(){var c=Data.Model.extend({attributes:["id"],idAttribute:"id"}),d=new c({id:1}),b=new c({id:2}),a=new Data.Collection([d]);Y.Assert.areSame(-1,a.indexOfId(2),"model2 is not in the collection, so indexOfId() should return -1")}},{name:"Test isModified()",setUp:function(){this.unmodifiedModel1=JsMockito.mock(Data.Model);JsMockito.when(this.unmodifiedModel1).getClientId().thenReturn(1);JsMockito.when(this.unmodifiedModel1).isModified().thenReturn(false);this.unmodifiedModel2=JsMockito.mock(Data.Model);JsMockito.when(this.unmodifiedModel2).getClientId().thenReturn(2);JsMockito.when(this.unmodifiedModel2).isModified().thenReturn(false);this.modifiedModel1=JsMockito.mock(Data.Model);JsMockito.when(this.modifiedModel1).getClientId().thenReturn(3);JsMockito.when(this.modifiedModel1).isModified().thenReturn(true);this.modifiedModel2=JsMockito.mock(Data.Model);JsMockito.when(this.modifiedModel2).getClientId().thenReturn(4);JsMockito.when(this.modifiedModel2).isModified().thenReturn(true);this.Collection=Data.Collection.extend({})},"isModified() should return false if no Models within the collection have been modified":function(){var a=new this.Collection([this.unmodifiedModel1]);Y.Assert.isFalse(a.isModified())},"isModified() should return true if a Model within the collection has been modified":function(){var a=new this.Collection([this.unmodifiedModel1,this.modifiedModel1]);Y.Assert.isTrue(a.isModified())},"isModified() should return true if a model has been added to the Collection since the last commit/rollback":function(){var a=new this.Collection();Y.Assert.isFalse(a.isModified(),"Initial condition: the collection should not be considered modified");a.add(this.unmodifiedModel1);Y.Assert.isTrue(a.isModified(),"The collection should now be modified, since a Model was added.")},"isModified() should return true if a model has been removed from the Collection since the last commit/rollback":function(){var a=new this.Collection([this.unmodifiedModel1,this.unmodifiedModel2]);Y.Assert.isFalse(a.isModified(),"Initial condition: the collection should not be considered modified");a.remove(this.unmodifiedModel1);Y.Assert.isTrue(a.isModified(),"The collection should now be modified, since a Model was removed.")},"isModified() should return true if a model has been reordered in the Collection since the last commit/rollback":function(){var a=new this.Collection([this.unmodifiedModel1,this.unmodifiedModel2]);Y.Assert.isFalse(a.isModified(),"Initial condition: the collection should not be considered modified");a.insert(this.unmodifiedModel1,1);Y.Assert.isTrue(a.isModified(),"The collection should now be modified, since a Model was reordered.")},"isModified() should return false when there is a change, but commit()/rollback() has been called":function(){var a=new this.Collection();Y.Assert.isFalse(a.isModified(),"Initial condition: the collection should not be considered modified");a.add(this.unmodifiedModel1);a.commit();Y.Assert.isFalse(a.isModified(),"The collection should no longer be considered modified, since a Model was added, and then committed.");a.add(this.unmodifiedModel2);a.rollback();Y.Assert.isFalse(a.isModified(),"The collection should no longer be considered modified, since a Model was added, and then rolled back.")}},{name:"Test find()",setUp:function(){this.Model=Data.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Data.Collection.extend({model:this.Model})},"find() should find a Model by attribute and value":function(){var d=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),b=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"});var a=new this.Collection([d,b]),c;c=a.find("boolAttr",false);Y.Assert.areSame(d,c,"did not find model by boolean false");c=a.find("boolAttr",true);Y.Assert.areSame(b,c,"did not find model by boolean true");c=a.find("numberAttr",0);Y.Assert.areSame(d,c,"did not find model by number 0");c=a.find("numberAttr",1);Y.Assert.areSame(b,c,"did not find model by number 1");c=a.find("stringAttr","");Y.Assert.areSame(d,c,"did not find model by empty string");c=a.find("stringAttr","value");Y.Assert.areSame(b,c,"did not find model by string value");c=a.find("stringAttr","ooglyBoogly");Y.Assert.isNull(c,"Finding a model by an attribute that doesn't exist should return null")},"find() should start at a given startIndex when provided":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.find("boolAttr",false,{startIndex:1});Y.Assert.areSame(a,d,"The model that was found should have been model3, because it is the only one that matched the criteria past the given startIndex")}},{name:"Test findBy()",setUp:function(){this.Model=Data.Model.extend({attributes:["boolAttr","numberAttr","stringAttr"]});this.Collection=Data.Collection.extend({model:this.Model})},"findBy should accept a function that when it returns true, it considers the Model the match":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.findBy(function(g,f){if(g.get("boolAttr")===true){return true}});Y.Assert.areSame(c,d)},"findBy should return null when there is no match":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.findBy(function(g,f){});Y.Assert.isNull(d)},"findBy should start at the given startIndex":function(){var e=new this.Model({boolAttr:false,numberAttr:0,stringAttr:""}),c=new this.Model({boolAttr:true,numberAttr:1,stringAttr:"value"}),a=new this.Model({boolAttr:false,numberAttr:2,stringAttr:"value2"});var b=new this.Collection([e,c,a]),d;d=b.findBy(function(g,f){if(g.get("boolAttr")===false){return true}},{startIndex:1});Y.Assert.areSame(a,d)}},{name:"Test sync()",createModels:function(c){var f=[],e=Data.attribute.Attribute.extend({constructor:function(){}});for(var b=0;b<c;b++){var a=JsMockito.mock(Data.Model),d=JsMockito.mock(e);JsMockito.when(d).getName().thenReturn("attribute_"+b);JsMockito.when(a).getIdAttribute().thenReturn(d);JsMockito.when(a).hasIdAttribute().thenReturn(true);JsMockito.when(a).getId().thenReturn(b);JsMockito.when(a).getClientId().thenReturn("c_"+b);JsMockito.when(a).isNew().thenReturn(false);JsMockito.when(a).isModified().thenReturn(false);f.push(a)}return f},"sync() should create (save) models that are new":function(){var c=this.createModels(2);JsMockito.when(c[0]).isNew().thenReturn(true);JsMockito.when(c[0]).save().then(function(){return(new jQuery.Deferred()).resolve(c[0])});var b=new Data.Collection(c);b.sync();try{JsMockito.verify(c[0]).save();JsMockito.verify(c[0],JsMockito.Verifiers.never()).destroy();JsMockito.verify(c[1],JsMockito.Verifiers.never()).save();JsMockito.verify(c[1],JsMockito.Verifiers.never()).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should save models that have been modified":function(){var c=this.createModels(2);JsMockito.when(c[0]).isModified().thenReturn(true);JsMockito.when(c[0]).save().then(function(){return(new jQuery.Deferred()).resolve(c[0])});var b=new Data.Collection(c);b.sync();try{JsMockito.verify(c[0]).save();JsMockito.verify(c[0],JsMockito.Verifiers.never()).destroy();JsMockito.verify(c[1],JsMockito.Verifiers.never()).save();JsMockito.verify(c[1],JsMockito.Verifiers.never()).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should destroy models that have been removed from the collection":function(){var c=this.createModels(2);JsMockito.when(c[0]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[0])});var b=new Data.Collection(c);b.remove(c[0]);b.sync();try{JsMockito.verify(c[0],JsMockito.Verifiers.never()).save();JsMockito.verify(c[0]).destroy();JsMockito.verify(c[1],JsMockito.Verifiers.never()).save();JsMockito.verify(c[1],JsMockito.Verifiers.never()).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should destroy models that have been removed from the collection in more than one call to remove() (to make sure the 'removedModels' is cumulative)":function(){var c=this.createModels(2);JsMockito.when(c[0]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[0])});JsMockito.when(c[1]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[1])});var b=new Data.Collection(c);b.remove(c[0]);b.remove(c[1]);b.sync();try{JsMockito.verify(c[0],JsMockito.Verifiers.never()).save();JsMockito.verify(c[0]).destroy();JsMockito.verify(c[1],JsMockito.Verifiers.never()).save();JsMockito.verify(c[1]).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should destroy models that have been removed from the collection, but if one fails, only that one should be attempted to be destroyed again upon the next sync()":function(){var c=this.createModels(2);JsMockito.when(c[0]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[0])});JsMockito.when(c[1]).destroy().then(function(){return(new jQuery.Deferred()).reject(c[1])},function(){return(new jQuery.Deferred()).resolve(c[1])});var b=new Data.Collection(c);b.remove(c[0]);b.remove(c[1]);b.sync();b.sync();try{JsMockito.verify(c[0],JsMockito.Verifiers.never()).save();JsMockito.verify(c[0],JsMockito.Verifiers.once()).destroy();JsMockito.verify(c[1],JsMockito.Verifiers.never()).save();JsMockito.verify(c[1],JsMockito.Verifiers.times(2)).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should destroy models that have been removed from the collection only on the first call to sync(). They should not be destroyed again afterwards.":function(){var c=this.createModels(2);JsMockito.when(c[0]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[0])});JsMockito.when(c[1]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[1])});var b=new Data.Collection(c);b.remove(c[0]);b.remove(c[1]);b.sync();b.sync();try{JsMockito.verify(c[0],JsMockito.Verifiers.never()).save();JsMockito.verify(c[0],JsMockito.Verifiers.once()).destroy();JsMockito.verify(c[1],JsMockito.Verifiers.never()).save();JsMockito.verify(c[1],JsMockito.Verifiers.once()).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should save models that are new and modified, and destroy models that have been removed.":function(){var c=this.createModels(4);JsMockito.when(c[0]).isNew().thenReturn(true);JsMockito.when(c[0]).save().then(function(){return(new jQuery.Deferred()).resolve(c[0])});JsMockito.when(c[1]).isModified().thenReturn(true);JsMockito.when(c[1]).save().then(function(){return(new jQuery.Deferred()).resolve(c[1])});JsMockito.when(c[3]).destroy().then(function(){return(new jQuery.Deferred()).resolve(c[3])});var b=new Data.Collection(c);b.remove(c[3]);b.sync();try{JsMockito.verify(c[0]).save();JsMockito.verify(c[0],JsMockito.Verifiers.never()).destroy();JsMockito.verify(c[1]).save();JsMockito.verify(c[1],JsMockito.Verifiers.never()).destroy();JsMockito.verify(c[2],JsMockito.Verifiers.never()).save();JsMockito.verify(c[2],JsMockito.Verifiers.never()).destroy();JsMockito.verify(c[3],JsMockito.Verifiers.never()).save();JsMockito.verify(c[3]).destroy()}catch(a){Y.Assert.fail(typeof a==="string"?a:a.message)}},"sync() should call the 'success' and 'complete' callbacks when no persistence operations need to be done on any of the Collection's models":function(){var e=this.createModels(4);var c=new Data.Collection(e);var b=0,d=0,a=0;c.sync({success:function(){b++},error:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,b,"The success callback should have been called exactly once");Y.Assert.areSame(0,d,"The error callback should not have been called");Y.Assert.areSame(1,a,"The complete callback should have been called exactly once")},"sync() should call the 'success' and 'complete' callbacks if all persistence operations succeed":function(){var e=this.createModels(4);JsMockito.when(e[0]).isNew().thenReturn(true);JsMockito.when(e[0]).save().then(function(){return(new jQuery.Deferred()).resolve(e[0])});JsMockito.when(e[1]).isModified().thenReturn(true);JsMockito.when(e[1]).save().then(function(){return(new jQuery.Deferred()).resolve(e[1])});JsMockito.when(e[3]).destroy().then(function(){return(new jQuery.Deferred()).resolve(e[3])});var c=new Data.Collection(e);c.remove(e[3]);var b=0,d=0,a=0;c.sync({success:function(){b++},error:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,b,"The success callback should have been called exactly once");Y.Assert.areSame(0,d,"The error callback should not have been called");Y.Assert.areSame(1,a,"The complete callback should have been called exactly once")},"sync() should call the 'error' and 'complete' callbacks if all persistence operations fail":function(){var e=this.createModels(4);JsMockito.when(e[0]).isNew().thenReturn(true);JsMockito.when(e[0]).save().then(function(){return(new jQuery.Deferred()).reject(e[0])});JsMockito.when(e[1]).isModified().thenReturn(true);JsMockito.when(e[1]).save().then(function(){return(new jQuery.Deferred()).reject(e[1])});JsMockito.when(e[3]).destroy().then(function(){return(new jQuery.Deferred()).reject(e[3])});var c=new Data.Collection(e);c.remove(e[3]);var b=0,d=0,a=0;c.sync({success:function(){b++},error:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,b,"The success callback should not have been called");Y.Assert.areSame(1,d,"The error callback should have been called exactly once");Y.Assert.areSame(1,a,"The complete callback should have been called exactly once")},"sync() should call the 'error' and 'complete' callbacks if just one of the persistence operations fail (in this case, the first persistence operation)":function(){var e=this.createModels(4);JsMockito.when(e[0]).isNew().thenReturn(true);JsMockito.when(e[0]).save().then(function(){return(new jQuery.Deferred()).reject(e[0])});JsMockito.when(e[1]).isModified().thenReturn(true);JsMockito.when(e[1]).save().then(function(){return(new jQuery.Deferred()).resolve(e[3])});JsMockito.when(e[3]).destroy().then(function(){return(new jQuery.Deferred()).resolve(e[3])});var c=new Data.Collection(e);c.remove(e[3]);var b=0,d=0,a=0;c.sync({success:function(){b++},error:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,b,"The success callback should not have been called");Y.Assert.areSame(1,d,"The error callback should have been called exactly once");Y.Assert.areSame(1,a,"The complete callback should have been called exactly once")},"sync() should call the 'error' and 'complete' callbacks if just one of the persistence operations fail (in this case, a middle persistence operation)":function(){var e=this.createModels(4);JsMockito.when(e[0]).isNew().thenReturn(true);JsMockito.when(e[0]).save().then(function(){return(new jQuery.Deferred()).resolve(e[0])});JsMockito.when(e[1]).isModified().thenReturn(true);JsMockito.when(e[1]).save().then(function(){return(new jQuery.Deferred()).reject(e[1])});JsMockito.when(e[3]).destroy().then(function(){return(new jQuery.Deferred()).resolve(e[3])});var c=new Data.Collection(e);c.remove(e[3]);var b=0,d=0,a=0;c.sync({success:function(){b++},error:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,b,"The success callback should not have been called");Y.Assert.areSame(1,d,"The error callback should have been called exactly once");Y.Assert.areSame(1,a,"The complete callback should have been called exactly once")},"sync() should call the 'error' and 'complete' callbacks if just one of the persistence operations fail (in this case, the last persistence operation)":function(){var e=this.createModels(4);JsMockito.when(e[0]).isNew().thenReturn(true);JsMockito.when(e[0]).save().then(function(){return(new jQuery.Deferred()).resolve(e[0])});JsMockito.when(e[1]).isModified().thenReturn(true);JsMockito.when(e[1]).save().then(function(){return(new jQuery.Deferred()).resolve(e[1])});JsMockito.when(e[3]).destroy().then(function(){return(new jQuery.Deferred()).reject(e[3])});var c=new Data.Collection(e);c.remove(e[3]);var b=0,d=0,a=0;c.sync({success:function(){b++},error:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,b,"The success callback should not have been called");Y.Assert.areSame(1,d,"The error callback should have been called exactly once");Y.Assert.areSame(1,a,"The complete callback should have been called exactly once")},"sync() should return a jQuery.Promise object which has its `done` and `always` callbacks executed when no models in the Collection need to be persisted":function(){var f=this.createModels(4);var e=new Data.Collection(f);var a=0,c=0,b=0;var d=e.sync().done(function(){a++}).fail(function(){c++}).always(function(){b++});Y.Assert.areSame(1,a,"The `done` callback should have been called exactly once");Y.Assert.areSame(0,c,"The `fail` callback should not have been called");Y.Assert.areSame(1,b,"The `always` callback should have been called exactly once")},"sync() should return a jQuery.Promise object which has its `done` and `always` callbacks executed when the sync of Models in the Collection succeeds":function(){var f=this.createModels(4);JsMockito.when(f[0]).isNew().thenReturn(true);JsMockito.when(f[0]).save().then(function(){return(new jQuery.Deferred()).resolve(f[0])});JsMockito.when(f[1]).isModified().thenReturn(true);JsMockito.when(f[1]).save().then(function(){return(new jQuery.Deferred()).resolve(f[1])});JsMockito.when(f[3]).destroy().then(function(){return(new jQuery.Deferred()).resolve(f[3])});var e=new Data.Collection(f);e.remove(f[3]);var a=0,c=0,b=0;var d=e.sync().done(function(){a++}).fail(function(){c++}).always(function(){b++});Y.Assert.areSame(1,a,"The `done` callback should have been called exactly once");Y.Assert.areSame(0,c,"The `fail` callback should not have been called");Y.Assert.areSame(1,b,"The `always` callback should have been called exactly once")},"sync() should return a jQuery.Promise object which has its `fail` and `always` callbacks executed when at least one of the operations of the sync fails":function(){var f=this.createModels(4);JsMockito.when(f[0]).isNew().thenReturn(true);JsMockito.when(f[0]).save().then(function(){return(new jQuery.Deferred()).resolve(f[0])});JsMockito.when(f[1]).isModified().thenReturn(true);JsMockito.when(f[1]).save().then(function(){return(new jQuery.Deferred()).reject(f[1])});JsMockito.when(f[3]).destroy().then(function(){return(new jQuery.Deferred()).resolve(f[3])});var e=new Data.Collection(f);e.remove(f[3]);var a=0,c=0,b=0;var d=e.sync().done(function(){a++}).fail(function(){c++}).always(function(){b++});Y.Assert.areSame(0,a,"The `done` callback should not have been called");Y.Assert.areSame(1,c,"The `fail` callback should have been called exactly once");Y.Assert.areSame(1,b,"The `always` callback should have been called exactly once")}}]}));tests.unit.data.add(new Ext.test.TestSuite({name:"Data.data.NativeObjectConverter",items:[{name:"Test convert() with a model","convert() should return a key for each of the Attributes in the Model, whether or not any data has been set to them":function(){var c=Data.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new c({attribute1:"value1"});var b=Data.data.NativeObjectConverter.convert(a);Y.ObjectAssert.hasKey("attribute1",b,"The data returned should have attribute1");Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.ObjectAssert.hasKey("attribute2",b,"The data returned should have attribute2, even though no value has been set to it");Y.Assert.isUndefined(b.attribute2,"attribute2 should be undefined in the returned data")},"convert() should return the data by running attributes' `get` functions (not just returning the raw data), when the `raw` option is not provided":function(){var c=Data.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(d){return"42 "+this.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2"});var b=Data.data.NativeObjectConverter.convert(a);Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"when the `raw` option is provided as true, convert() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Data.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(d){return"42 "+this.get("attribute1")}},{name:"attribute3",raw:function(d){return d+" "+this.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2",attribute3:"value3"});var b=Data.data.NativeObjectConverter.convert(a,{raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned")},"convert() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var c=Data.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=Data.data.NativeObjectConverter.convert(a,{persistedOnly:true});Y.Assert.areSame(2,_.keys(b).length,"The persisted data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The persisted data should have 'attribute1' and 'attribute3'")},"convert() should only retrieve the data for the persisted attributes in nested models (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var d=Data.Model.extend({attributes:[{name:"id",type:"string"},{name:"child",type:"model",embedded:true}]});var b=Data.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]});var f=new b({persistedAttr:"persisted",unpersistedAttr:"unpersisted"});var a=new d({id:1,child:f});f.set("unpersistedAttr","newValue");var c=Data.data.NativeObjectConverter.convert(a,{persistedOnly:true});Y.ObjectAssert.ownsKeys(["id","child"],c,"The persisted data for the parent model should have 'id' and 'child' attributes");var e=c.child;Y.Assert.areSame(1,_.keys(e).length,"The child data shoud only have 1 property in the data (the persisted one)");Y.ObjectAssert.ownsKeys(["persistedAttr"],e,"The child data should only have the 'persistedAttr' attribute")},"convert() should only process the attributes of a Model that are defined by the 'attributeNames' option (if provided)":function(){var c=Data.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=Data.data.NativeObjectConverter.convert(a,{attributeNames:["attribute1","attribute3"]});Y.Assert.areSame(2,_.keys(b).length,"The data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The data should only have 'attribute1' and 'attribute3'")},"Using the 'attributeNames' option should only affect the Model that is provided to convert(), not nested models":function(){var d=Data.Model.extend({attributes:["attribute1","attribute2"]});var a=new d({attribute1:new d({attribute1:"innerValue1",attribute2:"innerValue2"}),attribute2:"value2"});var c=Data.data.NativeObjectConverter.convert(a,{attributeNames:["attribute1"]});Y.Assert.areSame(1,_.keys(c).length,"The data should only have 1 property");Y.ObjectAssert.ownsKeys(["attribute1"],c,"attribute1 should exist on the return data");var b=c.attribute1;Y.Assert.areSame(2,_.keys(b).length,"The inner (nested) data should have 2 properties");Y.Assert.areSame("innerValue1",b.attribute1,"The inner (nested) attribute1 should have the correct value");Y.Assert.areSame("innerValue2",b.attribute2,"The inner (nested) attribute2 should have the correct value")},"convert() should deep convert nested models, while handing circular references":function(){var d=Data.Model.extend({addAttributes:["value","relatedModel"]});var a=new d(),c=new d();a.set("value","outerModel-value");a.set("relatedModel",c);c.set("value","innerModel-value");c.set("relatedModel",a);var b=Data.data.NativeObjectConverter.convert(a);Y.Assert.areSame(2,_.keys(b).length,"The outerModel data should only have 2 properties");Y.Assert.areSame("innerModel-value",b.relatedModel.value,"Should be able to access the inner model's value from the outer model.");Y.Assert.areSame("outerModel-value",b.relatedModel.relatedModel.value,"Should be able to access the outer model's value from the inner model");Y.Assert.areSame("innerModel-value",b.relatedModel.relatedModel.relatedModel.value,"Should be able to go around and around, just to make sure we have the circular dependency handled");Y.Assert.areSame(b,b.relatedModel.relatedModel,"The outer -> inner -> outer should point to the `data` object returned by the convert() method, as that is the model that was converted");Y.Assert.areSame(b.relatedModel.relatedModel,b.relatedModel.relatedModel.relatedModel.relatedModel,"The outer -> inner -> outer should point to the outer reference")}},{name:"Test convert() with a Collection","convert() should convert a Collection of Models into an Array of Objects":function(){var d=Data.Model.extend({attributes:["attr1","attr2"]});var a=Data.Collection.extend({model:d});var c=new a([{attr1:1,attr2:2},{attr1:3,attr2:4}]);var b=Data.data.NativeObjectConverter.convert(c);Y.Assert.isArray(b,"the data should be an array");Y.Assert.areSame(2,b.length,"There should be 2 items in the array");Y.Assert.areSame(1,b[0].attr1,"The first array item's attr1 should be 1");Y.Assert.areSame(2,b[0].attr2,"The first array item's attr2 should be 2");Y.Assert.areSame(3,b[1].attr1,"The second array item's attr1 should be 3");Y.Assert.areSame(4,b[1].attr2,"The second array item's attr2 should be 4")},"convert() should deep convert nested models/collections, while handing circular references":function(){var e=Data.Model.extend({attributes:["nestedCollection"]});var b=Data.Collection.extend({model:e});var a=new e();var d=new b();a.set("nestedCollection",d);d.add(a);var c=Data.data.NativeObjectConverter.convert(d);Y.Assert.isArray(c,"the data should be an array");Y.Assert.areSame(1,c.length,"There should be 1 item in the array");Y.Assert.isObject(c[0],"The data's first element should be an object");Y.Assert.isArray(c[0].nestedCollection,"The data's first element's nestedCollection should be an array");Y.Assert.areSame(c,c[0].nestedCollection,"The nested collection's array should refer back to the same array created for 'data'");Y.Assert.areSame(c,c[0].nestedCollection[0].nestedCollection[0].nestedCollection,"Nesty nesty nesty should work")},"convert() should simply return an array of objects with only an id property for each of the models in a Collection if 'raw' is true and the collection is not 'embedded'":function(){var f=Data.Model.extend({attributes:[{name:"nestedCollection",type:"collection",embedded:false}]});var c=Data.Model.extend({attributes:[{name:"id"},{name:"attr"}]});var b=Data.Collection.extend({model:c});var e=new b([{id:1,attr:"attr1"},{id:2,attr:"attr2"}]);var a=new f({nestedCollection:e});var d=Data.data.NativeObjectConverter.convert(a,{raw:true});Y.Assert.isObject(d,"the data should be an object");Y.Assert.isArray(d.nestedCollection,"The data returned should have nestedCollection as an array");Y.Assert.isObject(d.nestedCollection[0],"The first item in the array should be an object");Y.Assert.areSame(1,d.nestedCollection[0].id,"The first item in the array should have the correct id");Y.Assert.isFalse(d.nestedCollection[0].hasOwnProperty("attr"),"The 'attr' property should *not* exist in the object in the first item of the array");Y.Assert.isObject(d.nestedCollection[1],"The second item in the array should be an object");Y.Assert.areSame(2,d.nestedCollection[1].id,"The second item in the array should have the correct id");Y.Assert.isFalse(d.nestedCollection[1].hasOwnProperty("attr"),"The 'attr' property should *not* exist in the object in the second item of the array")}}]}));tests.unit.add(new Ext.test.TestCase({name:"Data.ModelCache",setUp:function(){this.MockModel1=function(){};this.MockModel1.__Data_modelTypeId="1";this.MockModel2=function(){};this.MockModel2.__Data_modelTypeId="2";Data.ModelCache.models={}},tearDown:function(){Data.ModelCache.models={}},"get() should return a reference to the same model provided to it if not providing an id":function(){var b=new this.MockModel1();var a=Data.ModelCache.get(b);Y.Assert.areSame(b,a)},"get() should *not* return a reference to the first model, when a second one is passed in with the same type (subclass), but not passing in any id's":function(){var d=new this.MockModel1(),b=new this.MockModel1();var a=Data.ModelCache.get(d);var c=Data.ModelCache.get(b);Y.Assert.areNotSame(a,c)},"get() should return a reference to the first model, when a second one is passed with the same id":function(){var d=new this.MockModel1();var b=new this.MockModel1();var a=Data.ModelCache.get(d,1);var c=Data.ModelCache.get(b,1);Y.Assert.areSame(a,c)},"get() should *not* return a reference to the first model, when a second one is passed with the same id, but of a different model type (subclass)":function(){var d=new this.MockModel1(),b=new this.MockModel2();var a=Data.ModelCache.get(d,1);var c=Data.ModelCache.get(b,1);Y.Assert.areNotSame(a,c)},"get() should *not* return a reference to the first model, when a second one is passed with the same type (subclass), but with a different id":function(){var d=new this.MockModel1(),b=new this.MockModel1();var a=Data.ModelCache.get(d,1);var c=Data.ModelCache.get(b,2);Y.Assert.areNotSame(a,c)}}));tests.unit.add(new Ext.test.TestSuite({name:"Data.Model",items:[{name:"Test the onClassExtended static method","After extending model, the subclass should have a unique __Data_modelTypeId property":function(){var a=Data.Model.extend({});Y.Assert.isString(a.__Data_modelTypeId,"The Model should now have a static __Data_modelTypeId property that is a string")},"Attributes should inherit from a Model subclass's superclass when the subclass defines no attributes of its own":function(){var c=Data.Model.extend({attributes:["field1"]});var b=c.extend({});var a=(new b()).attributes;Y.Assert.areSame(1,_.keys(a).length,"There should be exactly 1 attribute");Y.ObjectAssert.hasKey("field1",a,"field1 should exist as the attribute")},"Attributes should inherit from a Model subclass's superclass when the subclass does define attributes of its own":function(){var c=Data.Model.extend({});var b=c.extend({addAttributes:["a","b"]});var a=(new b()).attributes;Y.Assert.areSame(2,_.keys(a).length,"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and its superclass as well (i.e. more than one level up)":function(){var d=Data.Model.extend({});var b=Class.extend(d,{addAttributes:["a","b"]});var c=Class.extend(b,{addAttributes:["c","d","e"]});var a=(new c()).attributes;Y.Assert.areSame(5,_.keys(a).length,"There should be exactly 5 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.")},"Attributes should inherit from a Model subclass's superclass, and all of its superclasses (i.e. more than two levels up)":function(){var e=Data.Model.extend({});var c=Class.extend(e,{addAttributes:["a","b"]});var d=Class.extend(c,{addAttributes:["c","d","e"]});var b=Class.extend(d,{addAttributes:["f"]});var a=(new b()).attributes;Y.Assert.areSame(6,_.keys(a).length,"There should be exactly 6 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("d",a,"SubSubSubClassModel should have the 'd' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("e",a,"SubSubSubClassModel should have the 'e' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("f",a,"SubSubSubClassModel should have the 'f' attribute defined in its final 'attributes' hash.")},"Attribute definitions defined in a subclass should take precedence over attribute definitions in a superclass":function(){var d=Data.Model.extend({});var b=Class.extend(d,{addAttributes:[{name:"a",defaultValue:1}]});var c=Class.extend(b,{addAttributes:[{name:"a",defaultValue:2},"b"]});var a=(new c()).attributes;Y.Assert.areSame(2,_.keys(a).length,"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.Assert.areSame(2,a.a.defaultValue,"The attribute in the subclass should have overridden its superclass")},"A subclass that doesn't define any attributes should inherit all of them from its superclass(es)":function(){var d=Data.Model.extend({});var b=Class.extend(d,{addAttributes:["a","b"]});var c=Class.extend(b,{});var a=(new c()).attributes;Y.Assert.areSame(2,_.keys(a).length,"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"A superclass that doesn't define any attributes should be skipped for attributes, but the subclass should still inherit from superclasses above it":function(){var d=Data.Model.extend({});var b=Class.extend(d,{});var c=Class.extend(b,{addAttributes:["a","b"]});var a=(new c()).attributes;Y.Assert.areSame(2,_.keys(a).length,"There should be exactly 2 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.")},"One should be able to use `attributes` in place of `addAttributes` on the prototype, if they wish":function(){var c=Data.Model.extend({attributes:["a","b"]});var b=c.extend({attributes:["c"]});var a=(new b()).attributes;Y.Assert.areSame(3,_.keys(a).length,"There should be exactly 3 attributes");Y.ObjectAssert.hasKey("a",a,"SubSubClassModel should have the 'a' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("b",a,"SubSubClassModel should have the 'b' attribute defined in its final 'attributes' hash.");Y.ObjectAssert.hasKey("c",a,"SubSubClassModel should have the 'c' attribute defined in its final 'attributes' hash.")}},{name:"Test the getAttributes() static method","The getAttributes() static method should retrieve a hashmap of the attributes for the model":function(){var a=Data.Model.extend({attributes:[{name:"id",type:"number"},{name:"superclassAttr",type:"string"}]});var c=a.extend({attributes:[{name:"subclassAttr",type:"boolean"}]});var f=a.getAttributes();var e=_.keys(f);Y.Assert.areSame(2,e.length,"There should have been 2 keys in the array for the superclassModelAttrKeys");Y.Assert.isTrue(_.contains(e,"id"),"The key 'id' should exist");Y.Assert.isTrue(_.contains(e,"superclassAttr"),"The key 'superclassAttr' should exist");Y.Assert.isInstanceOf(Data.attribute.NumberAttribute,f.id,"The `id` Attribute should have been an instance of NumberAttribute");Y.Assert.isInstanceOf(Data.attribute.StringAttribute,f.superclassAttr,"The `superclassAttr` Attribute should have been an instance of StringAttribute");var b=c.getAttributes();var d=_.keys(b);Y.Assert.areSame(3,d.length,"There should have been 3 keys in the array for the subclassModelAttrKeys");Y.Assert.isTrue(_.contains(d,"id"),"The key 'id' should exist");Y.Assert.isTrue(_.contains(d,"superclassAttr"),"The key 'superclassAttr' should exist");Y.Assert.isTrue(_.contains(d,"subclassAttr"),"The key 'subclassAttr' should exist");Y.Assert.isInstanceOf(Data.attribute.NumberAttribute,b.id,"The `id` Attribute should have been an instance of NumberAttribute");Y.Assert.isInstanceOf(Data.attribute.StringAttribute,b.superclassAttr,"The `superclassAttr` Attribute should have been an instance of StringAttribute");Y.Assert.isInstanceOf(Data.attribute.BooleanAttribute,b.subclassAttr,"The `subclassAttr` Attribute should have been an instance of BooleanAttribute")}},{name:"Test Initialization (constructor)",ttype:"testsuite",items:[{name:"Test lazy instantiating a persistenceProxy",_should:{error:{"Attempting to instantiate a persistenceProxy with no 'type' attribute should throw an error":"Data.persistence.Proxy.create(): No `type` property provided on persistenceProxy config object","Attempting to instantiate a persistenceProxy with an invalid 'type' attribute should throw an error":"Data.persistence.Proxy.create(): Unknown Proxy type: 'nonexistentproxy'"}},"Attempting to instantiate a persistenceProxy with no 'type' attribute should throw an error":function(){var b=Class.extend(Data.Model,{addAttributes:["attribute1"],persistenceProxy:{}});var a=new b()},"Attempting to instantiate a persistenceProxy with an invalid 'type' attribute should throw an error":function(){var b=Class.extend(Data.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"nonExistentProxy"}});var a=new b()},"Providing a valid config object should instantiate the Proxy *on class's the prototype*":function(){var b=Class.extend(Data.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"rest"}});var a=new b();Y.Assert.isInstanceOf(Data.persistence.RestProxy,b.prototype.persistenceProxy)},"Providing a valid config object should instantiate the Proxy *on the correct subclass's prototype*, shadowing superclasses":function(){var b=Class.extend(Data.Model,{addAttributes:["attribute1"],persistenceProxy:{type:"nonExistentProxy"}});var c=Class.extend(b,{addAttributes:["attribute1"],persistenceProxy:{type:"rest"}});var a=new c();Y.Assert.isInstanceOf(Data.persistence.RestProxy,c.prototype.persistenceProxy)}},{name:"Test change event upon initialization",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+a.get("attribute2")}}]})},"The Model should fire its 'change' event when an attribute's data is set externally":function(){var b=false;var a=new this.TestModel();a.addListener("change",function(){b=true});a.set("attribute1","value1");Y.Assert.isTrue(b,"The change event should have been fired during the set of the new data")}},{name:"Test that the initial default values are applied",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"A attribute with a defaultValue but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"A attribute with a defaultValue that is a function, but no provided data should have its defaultValue when retrieved":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"A attribute with a defaultValue and also provided data should have its provided data when retrieved":function(){var a=new this.TestModel({attribute2:"attribute2's data"});Y.Assert.areSame("attribute2's data",a.get("attribute2"),"The 'default' specified on the Attribute should *not* have been applied, since it has a value.")}},{name:"Test initial data","Providing initial data to the constructor should not leave the model set as 'dirty' (i.e. it should have no 'changes')":function(){var b=Data.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new b({attribute1:"value1",attribute2:"value2"});Y.Assert.isFalse(a.isDirty(),"The model should not be dirty upon initialization");Y.Assert.isTrue(_.isEmpty(a.getChanges()),"There should not be any 'changes' upon initialization")}},{name:"Test that initialize() is called","The initialize() method should be called with the constructor function, for subclass initialization":function(){var b=false;var c=Data.Model.extend({addAttributes:["test",{name:"test2",defaultValue:"defaultForTest2"}],initialize:function(){b=true}});var a=new c();Y.Assert.isTrue(b,"The initialize() method should have been called")}}]},{name:"Test getId()",_should:{error:{"getId() should throw an error if the default idAttribute 'id' does not exist on the model":"Error: The `idAttribute` (currently set to an attribute named 'id') was not found on the Model. Set the `idAttribute` config to the name of the id attribute in the Model. The model can't be saved or destroyed without it.","getId() should throw an error with a custom idAttribute that does not relate to an attribute on the model":"Error: The `idAttribute` (currently set to an attribute named 'myIdAttribute') was not found on the Model. Set the `idAttribute` config to the name of the id attribute in the Model. The model can't be saved or destroyed without it."}},"getId() should throw an error if the default idAttribute 'id' does not exist on the model":function(){var b=Data.Model.extend({attributes:["field1","field2"]});var a=new b();a.getId();Y.Assert.fail("The test should have errored")},"getId() should throw an error with a custom idAttribute that does not relate to an attribute on the model":function(){var b=Data.Model.extend({attributes:["field1","field2"],idAttribute:"myIdAttribute"});var a=new b();a.getId();Y.Assert.fail("The test should have errored")},"getId() should return the value of the idAttribute":function(){var b=Data.Model.extend({attributes:["myIdAttribute"],idAttribute:"myIdAttribute"});var a=new b({myIdAttribute:1});Y.Assert.areSame(1,a.getId())}},{name:"Test getIdAttribute()","getIdAttribute() should return the Data.attribute.Attribute referenced by the 'idAttribute' config":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"id"});var a=new b();Y.Assert.isInstanceOf(Data.attribute.Attribute,a.getIdAttribute())},"getIdAttribute() should return null if there is no attribute referenced by the 'idAttribute' config":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"ooglyBoogly"});var a=new b();Y.Assert.isNull(a.getIdAttribute())}},{name:"Test getIdAttributeName()","getIdAttributeName() should return the value of the 'idAttribute' config":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"myBrandyNewIdAttribute"});var a=new b();Y.Assert.areSame("myBrandyNewIdAttribute",a.getIdAttributeName())}},{name:"Test hasIdAttribute()","hasIdAttribute should return false when the idAttribute config does not reference a valid Attribute":function(){var b=Data.Model.extend({attributes:["attr"],idAttribute:"id"});var a=new b();Y.Assert.isFalse(a.hasIdAttribute())},"hasIdAttribute should return truue when the idAttribute config does reference a valid Attribute":function(){var b=Data.Model.extend({attributes:["id","attr"],idAttribute:"id"});var a=new b();Y.Assert.isTrue(a.hasIdAttribute())}},{name:"Test set()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},_should:{error:{"set() should throw an error when trying to set an attribute that isn't defined (using the attr and value args)":"Data.Model.set(): An attribute with the attributeName 'nonExistentAttr' was not found.","set() should throw an error when trying to set an attribute that isn't defined (using the attr as an object literal arg)":"Data.Model.set(): An attribute with the attributeName 'nonExistentAttr' was not found."}},"set() should throw an error when trying to set an attribute that isn't defined (using the attr and value args)":function(){var a=new this.TestModel();a.set("nonExistentAttr",1);Y.Assert.fail("Test should have thrown an error")},"set() should throw an error when trying to set an attribute that isn't defined (using the attr as an object literal arg)":function(){var a=new this.TestModel();a.set({nonExistentAttr:1});Y.Assert.fail("Test should have thrown an error")},assertAttributeAcceptsAll:function(b,a){b.set(a,undefined);Y.Assert.isUndefined(b.get(a),a+"'s value should have the value set by set() (undefined).");b.set(a,null);Y.Assert.isNull(b.get(a),a+"'s value should have the value set by set() (null).");b.set(a,true);Y.Assert.isTrue(b.get(a),a+"'s value should have the value set by set() (true).");b.set(a,false);Y.Assert.isFalse(b.get(a),a+"'s value should have the value set by set() (false).");b.set(a,0);Y.Assert.areSame(0,b.get(a),a+"'s value should have the value set by set() (0).");b.set(a,1);Y.Assert.areSame(1,b.get(a),a+"'s value should have the value set by set() (1).");b.set(a,"");Y.Assert.areSame("",b.get(a),a+"'s value should have the value set by set() ('').");b.set(a,"Hello");Y.Assert.areSame("Hello",b.get(a),a+"'s value should have the value set by set() ('Hello').");b.set(a,{});Y.Assert.isObject(b.get(a),a+"'s value should have the value set by set() (object).");b.set(a,[]);Y.Assert.isArray(b.get(a),a+"'s value should have the value set by set() (array).")},"set() should accept all datatypes including falsy values":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute1")},"set() should accept all datatypes, and still work even with a default value":function(){var a=new this.TestModel();this.assertAttributeAcceptsAll(a,"attribute2")},"set() should accept all datatypes, and still work even with a given value":function(){var a=new this.TestModel({attribute2:"initial value"});this.assertAttributeAcceptsAll(a,"attribute2")},"After the successful set() of an attribute, the Model should be considered 'dirty'":function(){var b=Data.Model.extend({addAttributes:["attribute1"]});var a=new b();Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isTrue(a.isDirty(),"After a set, the model should now be considered 'dirty'")},"After a set() of an attribute to the same value from a clean state, the Model should NOT be considered 'dirty' (as the value didn't change)":function(){var b=Data.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});Y.Assert.isFalse(a.isDirty(),"Initially, the model should not be considered 'dirty'");a.set("attribute1","value1");Y.Assert.isFalse(a.isDirty(),"After a set to the *same value*, the model should not be considered 'dirty' (as the value didn't change)")},"set() should not re-set an attribute to the same value from the initial value provided to the constructor":function(){var c=0;var b=Data.Model.extend({addAttributes:["attribute1"]});var a=new b({attribute1:"value1"});a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(0,c,"The attribute should not have been registered as 'changed' when providing the same value")},"set() should not re-set an attribute to the same value":function(){var c=0;var b=Data.Model.extend({addAttributes:["attribute1"]});var a=new b();a.addListener("change:attribute1",function(){c++});a.set("attribute1","value1");Y.Assert.areSame(1,c,"Initially, the attribute should have been changed exactly once.");a.set("attribute1","value1");Y.Assert.areSame(1,c,"The attribute should not have been registered as 'changed' the second time. Should still only have '1 change'.")},"set() should run the Attribute's set() method on an attribute that has initial data of its own":function(){var b=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(c){return c+" "+this.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute2val attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute1")},"set() should convert an attribute with a 'set' function when it is set() again":function(){var b=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(c){return c+" "+this.get("attribute1")}}]});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});a.set("attribute2","newattribute2value");Y.Assert.areSame("newattribute2value attribute1val",a.get("attribute2"),"attribute2 should be the concatenation of its own value, a space, and attribute2")},"When set() is provided an Object (hashmap) of data to set, the attributes with user-provided 'set' methods should be run after ones with out any (in case they rely on the ones without setters)":function(){var b=Data.Model.extend({attributes:[{name:"attr_with_setter1",set:function(c){return this.get("attr_without_setter")+c}},{name:"attr_without_setter"},{name:"attr_with_setter2",set:function(c){return this.get("attr_without_setter")+c}}]});var a=new b();a.set({attr_with_setter1:1,attr_without_setter:2,attr_with_setter2:3});Y.Assert.areSame(3,a.get("attr_with_setter1"),"The value should have been added from the attr_without_setter");Y.Assert.areSame(2,a.get("attr_without_setter"),"The value should have been simply provided to attr_without_setter");Y.Assert.areSame(5,a.get("attr_with_setter2"),"The value should have been added from the attr_without_setter")},"set() should delegate to the Attribute's beforeSet() and afterSet() methods to do any pre and post processing needed for the value":function(){var e,b;var a=Data.attribute.Attribute.extend({beforeSet:function(g,h,f){return(e=h+1)},afterSet:function(f,g){return(b=g+20)}});var d=Data.Model.extend({attributes:[new a({name:"attr1",set:function(f){return f+5}})]});var c=new d({attr1:0});Y.Assert.areSame(1,e);Y.Assert.areSame(26,b)},"When an attribute is set, a generalized 'change' event should be fired":function(){var c=Class.extend(Data.Model,{addAttributes:["attribute1","attribute2"]});var b=new c(),d=false,e,f,a;b.addListener("change",function(h,g,j,i){d=true;e=g;f=j;a=i});b.set("attribute2","brandNewValue");Y.Assert.isTrue(d,"The 'change' event was not fired");Y.Assert.areSame("attribute2",e,"The attributeName that was changed was not provided to the event correctly.");Y.Assert.areSame("brandNewValue",f,"The value for attribute2 that was changed was not provided to the event correctly.");Y.Assert.isUndefined(a,"The oldValue for attribute2 that was changed was not provided to the event correctly. Should have been undefined, from having no original value")},"When an attribute is set, a 'change:xxx' event should be fired for the changed attribute":function(){var c=Class.extend(Data.Model,{addAttributes:["attribute1","attribute2"]});var b=new c(),d=false,e,a;b.addListener("change:attribute2",function(f,h,g){d=true;e=h;a=g});b.set("attribute2","brandNewValue");Y.Assert.isTrue(d,"The 'change:attribute2' event was not fired");Y.Assert.areSame("brandNewValue",e,"The value for attribute2 that was changed was not provided to the event correctly.");Y.Assert.isUndefined(a,"The oldValue for attribute2 that was changed was not provided to the event correctly. Should have been undefined, from having no original value")},"When an attribute with a `set()` function of its own is set, the 'change' events should be fired":function(){var b=Class.extend(Data.Model,{addAttributes:[{name:"attribute1",set:function(g){return g}},{name:"attribute2",set:function(g){}}]});var a=new b(),e=0,f,c=0,d;a.addListener("change:attribute1",function(g,h){e++;f=h});a.addListener("change:attribute2",function(g,h){c++;d=h});a.set("attribute1","attribute1value1");Y.Assert.areSame(1,e,"The attribute1 change event count should now be 1, with the initial value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value1",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should now be 2, with a new value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");Y.Assert.areSame("attribute1value2",f,"The attribute1 change event value was not correct");a.set("attribute1","attribute1value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, being set to the same value");Y.Assert.areSame(0,c,"The attribute2 change event count should still be 0, as no set has been performed on it yet");a.set("attribute2","attribute2value1");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it");Y.Assert.areSame(1,c,"The attribute2 change event count should now be 1, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should have been undefined, as its set() function does not return anything");a.set("attribute2","attribute2value2");Y.Assert.areSame(2,e,"The attribute1 change event count should still be 2, as no new set has been performed on it (2nd time)");Y.Assert.areSame(2,c,"The attribute2 change event count should now be 2, since a set has been performed on it");Y.Assert.isUndefined(d,"The attribute2 change event value should still be undefined, as its set() function does not return anything")},"When an attribute with only a `get()` function is set, the 'change' events should be fired with the value from the get function, not the raw value (for both the newValue, and oldValue)":function(){var d=Class.extend(Data.Model,{attributes:[{name:"myAttribute",get:function(g){return g+10}}]});var c=new d({myAttribute:10}),e,a,f,b;c.on({change:function(i,h,j,g){e=j;a=g},"change:myAttribute":function(h,i,g){f=i;b=g}});c.set("myAttribute",42);Y.Assert.areSame(52,e,"The newValue provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(20,a,"The oldValue provided with the change event should have come from myAttribute's `get()` function");Y.Assert.areSame(52,f,"The newValue provided with the attribute-specific change event should have come from myAttribute's `get()` function");Y.Assert.areSame(20,b,"The oldValue provided with the attribute-specific change event should have come from myAttribute's `get()` function")},"When an attribute with both a `set()` function, and `get()` function of its own is set, the 'change' events should be fired with the value from the `get()` function, not the raw value":function(){var d=Class.extend(Data.Model,{addAttributes:["baseAttribute",{name:"computedAttribute",set:function(g){this.set("baseAttribute",g)},get:function(g){return this.get("baseAttribute")+10}}]});var c=new d({baseAttribute:10}),e,a,f,b;c.on({change:function(i,h,j,g){e=j;a=g},"change:computedAttribute":function(h,i,g){f=i;b=g}});c.set("computedAttribute",42);Y.Assert.areSame(52,e,"The newValue provided with the change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(20,a,"The oldValue provided with the change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(52,f,"The newValue provided with the attribute-specific change event should have come from computedAttribute's `get()` function");Y.Assert.areSame(20,b,"The oldValue provided with the attribute-specific change event should have come from computedAttribute's `get()` function")},"When multiple attributes are set, a generalized 'changeset' event should be fired exactly once":function(){var e=Class.extend(Data.Model,{addAttributes:["a","b","c","unModifiedAttr"]});var d=new e({a:1,b:2,c:3}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b");Y.Assert.areSame(3,d.get("c"),"initial value for c");d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set({a:11,b:22,c:33});Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(3,_.keys(c).length,"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,_.keys(a).length,"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(22,c.b,"newValue for 'b'");Y.Assert.areSame(33,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'")},"When a computed attribute changes other attributes, the generalized 'changeset' event should still be only fired exactly once":function(){var e=Class.extend(Data.Model,{addAttributes:[{name:"a",set:function(f){this.set("b",f+1);this.set("c",f+2);return f}},{name:"b"},{name:"c"},{name:"unModifiedAttr"}]});var d=new e({a:1}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b. Should be set by the 'a' attribute's setter");Y.Assert.areSame(3,d.get("c"),"initial value for c. Should be set by the 'a' attribute's setter");d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set("a",11);Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(12,d.get("b"));Y.Assert.areSame(13,d.get("c"));Y.Assert.areSame(3,_.keys(c).length,"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,_.keys(a).length,"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(12,c.b,"newValue for 'b'");Y.Assert.areSame(13,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'")},"When an attribute changes, and a handler of the change ends up setting other attributes, the generalized 'changeset' event should still be only fired exactly once":function(){var e=Class.extend(Data.Model,{addAttributes:[{name:"a"},{name:"b"},{name:"c"},{name:"unModifiedAttr"}]});var d=new e({a:1,b:2,c:3}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b");Y.Assert.areSame(3,d.get("c"),"initial value for c");d.addListener("change:a",function(g,h,f){g.set("b",22);g.set("c",33)});d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set("a",11);Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(22,d.get("b"));Y.Assert.areSame(33,d.get("c"));Y.Assert.areSame(3,_.keys(c).length,"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,_.keys(a).length,"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(22,c.b,"newValue for 'b'");Y.Assert.areSame(33,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'")},"When an attribute is changed multiple times within a single 'changeset', its oldValue value should have its *original* value (not any intermediate values)":function(){var e=Class.extend(Data.Model,{addAttributes:[{name:"a"}]});var d=new e({a:1}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");d.addListener("change:a",function(g,h,f){g.set("a",3);g.set("a",4)},this,{single:true});d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set("a",2);Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(4,d.get("a"));Y.Assert.areSame(1,_.keys(c).length,"The changeset's newValues should have exactly 1 property");Y.Assert.areSame(1,_.keys(a).length,"The changeset's oldValues should have exactly 1 property");Y.Assert.areSame(4,c.a,"newValue for 'a'");Y.Assert.areSame(1,a.a,"oldValue for 'a'")},"multiple 'changeset' events should work correctly, providing the correct newValues and oldValues each time":function(){var e=Class.extend(Data.Model,{addAttributes:[{name:"a"},{name:"b"},{name:"c"},{name:"unModifiedAttr"}]});var d=new e({a:1,b:2,c:3}),b=0,c,a;Y.Assert.areSame(1,d.get("a"),"initial value for a");Y.Assert.areSame(2,d.get("b"),"initial value for b");Y.Assert.areSame(3,d.get("c"),"initial value for c");d.addListener("changeset",function(h,g,f){b++;c=g;a=f});d.set({a:11,b:22,c:33});Y.Assert.areSame(1,b,"The 'changeset' event should have been fired exactly once");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(22,d.get("b"));Y.Assert.areSame(33,d.get("c"));Y.Assert.areSame(3,_.keys(c).length,"The changeset's newValues should have exactly 3 properties");Y.Assert.areSame(3,_.keys(a).length,"The changeset's oldValues should have exactly 3 properties");Y.Assert.areSame(11,c.a,"newValue for 'a'");Y.Assert.areSame(22,c.b,"newValue for 'b'");Y.Assert.areSame(33,c.c,"newValue for 'c'");Y.Assert.areSame(1,a.a,"oldValue for 'a'");Y.Assert.areSame(2,a.b,"oldValue for 'b'");Y.Assert.areSame(3,a.c,"oldValue for 'c'");d.set({b:222,c:333});Y.Assert.areSame(2,b,"The 'changeset' event should have been fired exactly twice at this point (one more than the last test)");Y.Assert.areSame(11,d.get("a"));Y.Assert.areSame(222,d.get("b"));Y.Assert.areSame(333,d.get("c"));Y.Assert.areSame(2,_.keys(c).length,"The changeset's newValues should have exactly 2 properties");Y.Assert.areSame(2,_.keys(a).length,"The changeset's oldValues should have exactly 2 properties");Y.Assert.areSame(222,c.b,"newValue for 'b'");Y.Assert.areSame(333,c.c,"newValue for 'c'");Y.Assert.areSame(22,a.b,"oldValue for 'b'");Y.Assert.areSame(33,a.c,"oldValue for 'c'")},"for compatibility with Backbone's Collection, set() should set the id property to the Model object itself with the idAttribute is changed":function(){var b=Data.Model.extend({addAttributes:[{name:"attribute1"},{name:"attribute2",set:function(c){return c+" "+this.get("attribute1")}}],idAttribute:"attribute1"});var a=new b({attribute1:"attribute1val",attribute2:"attribute2val"});Y.Assert.areSame("attribute1val",a.id,"The model's `id` property should have been set to attribute1's value, as that is the idAttribute.");a.set("attribute1","newValue");Y.Assert.areSame("newValue",a.id,"The model's `id` property should have been set to attribute1's value after another set(), as that is the idAttribute.")}},{name:"Test get()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",get:function(a){return this.get("attribute1")+" "+this.get("attribute2")}}]})},"running get() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.get("attribute1"))},"running get() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.get("attribute1"))},"running get() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.get("attribute2"))},"running get() on an attribute with an initial value and a default value should return the initial value":function(){var a=new this.TestModel({attribute2:"initial value"});Y.Assert.areSame("initial value",a.get("attribute2"))},"running get() on an attribute with no initial value but does have a default value which is a function should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.get("attribute3"))},"running get() on an attribute with a `get` function defined should return the value that the `get` function returns":function(){var a=new this.TestModel({attribute1:"value1"});Y.Assert.areSame("value1 attribute2's default",a.get("attribute5"))}},{name:"Test raw()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",get:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute4",raw:function(a){return a+" "+this.get("attribute1")}}]})},"running raw() on an attribute with no initial value and no default value should return undefined":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.raw("attribute1"))},"running raw() on an attribute with an initial value and no default value should return the initial value":function(){var a=new this.TestModel({attribute1:"initial value"});Y.Assert.areSame("initial value",a.raw("attribute1"))},"running raw() on an attribute with no initial value but does have a default value should return the default value":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.raw("attribute2"))},"running raw() on an attribute with a `get` function defined should return the *underlying* value, not the value that the `get` function returns":function(){var a=new this.TestModel({attribute3:"value1"});Y.Assert.areSame("value1",a.raw("attribute3"))},"running raw() on an attribute with a `raw` function defined should return the value that the `raw` function returns":function(){var a=new this.TestModel({attribute1:"value1",attribute4:"value4"});Y.Assert.areSame("value4 value1",a.raw("attribute4"))}},{name:"Test getDefault()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"A attribute with no defaultValue should return undefined when trying to retrieve its default value":function(){var a=new this.TestModel();Y.Assert.isUndefined(a.getDefault("attribute1"))},"A defaultValue should be able to be retrieved directly when the attribute has one":function(){var a=new this.TestModel();Y.Assert.areSame("attribute2's default",a.getDefault("attribute2"))},"A defaultValue should be able to be retrieved directly when the defaultValue is a function that returns its default":function(){var a=new this.TestModel();Y.Assert.areSame("attribute3's default",a.getDefault("attribute3"))}},{name:"Test onEmbeddedDataComponentChange()","onEmbeddedDataComponentChange() should ":function(){}},{name:"Test isDirty()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"isDirty() should return false after instantiating a Model with no data":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after instantiating a Model with initial data":function(){var a=new this.TestModel({attribute1:1,attribute2:2});Y.Assert.isFalse(a.isDirty())},"isDirty() should return true after setting an attribute's data":function(){var a=new this.TestModel();a.set("attribute1",1);Y.Assert.isTrue(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then rolling back the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.rollback();Y.Assert.isFalse(a.isDirty())},"isDirty() should return false after setting an attribute's data, and then committing the data":function(){var a=new this.TestModel();a.set("attribute1",1);a.commit();Y.Assert.isFalse(a.isDirty())}},{name:"Test isModified()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]});this.ConcreteDataComponentAttribute=Data.attribute.DataComponentAttribute.extend({});this.ConcreteDataComponent=Data.DataComponent.extend({getData:Data.emptyFn,isModified:Data.emptyFn,commit:Data.emptyFn,rollback:Data.emptyFn})},"isModified should return false if there are no changes on the model":function(){var a=new this.TestModel();Y.Assert.isFalse(a.isModified())},"isModified should return true if there is at least one change on the model":function(){var a=new this.TestModel();a.set("attribute1","newValue1");Y.Assert.isTrue(a.isModified())},"isModified should return true if there are multiple changes on the model":function(){var a=new this.TestModel();a.set("attribute1","newValue1");a.set("attribute2","newValue2");Y.Assert.isTrue(a.isModified())},"isModified() should return false for particular attributes that have not been changed, even if there are other changes":function(){var a=new this.TestModel();a.set("attribute3","testing123");Y.Assert.isFalse(a.isModified("attribute1"),"attribute1, with no defaultValue, should not be modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2, with a defaultValue, should not be modified")},"isModified() should return true for particular attributes that have been changed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified");Y.Assert.isTrue(a.isModified("attribute2"),"attribute2 should be marked as modified")},"isModified() should return false for particular attributes that have been changed, but then committed":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been committed, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been committed, and therefore not marked as modified")},"isModified() should return false for particular attributes that have been changed, but then rolled back":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.rollback();Y.Assert.isFalse(a.isModified("attribute1"),"attribute1 should have been rolled back, and therefore not marked as modified");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should have been rolled back, and therefore not marked as modified")},"In the case of embedded DataComponents, the parent model should be considered 'modified' when a child embedded DataComponent has changes":function(){var b=Data.Model.extend({attributes:[new this.ConcreteDataComponentAttribute({name:"child",embedded:true})]});var c=JsMockito.mock(this.ConcreteDataComponent);JsMockito.when(c).isModified().thenReturn(true);var a=new b({child:c});Y.Assert.isTrue(a.isModified(),"The parent model should be considered 'modified' while its child model is 'modified'");Y.Assert.isTrue(a.isModified("child"),"The 'child' attribute should be considered 'modified'")},"The parent model should *not* have changes when a child model has changes, but is not 'embedded'":function(){var b=Data.Model.extend({attributes:[new this.ConcreteDataComponentAttribute({name:"child",embedded:false})]});var c=JsMockito.mock(this.ConcreteDataComponent);JsMockito.when(c).isModified().thenReturn(true);var a=new b({child:c});Y.Assert.isFalse(a.isModified(),"The parent model should not be considered 'modified' even though its child model is 'modified', because the child is not 'embedded'")},"If the persistedOnly option is provided as true, isModified() should return true only if a persisted attribute is modified":function(){var b=Data.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]});var a=new b();Y.Assert.isFalse(a.isModified(),"Initial condition: the model should not be considered modified");a.set("unpersistedAttr","value1");Y.Assert.isTrue(a.isModified(),"The model should be considered 'modified' in general");Y.Assert.isFalse(a.isModified({persistedOnly:true}),"The model only has unpersisted attributes modified, so this call should return false");a.set("persistedAttr","value1");Y.Assert.isTrue(a.isModified(),"The model should still be considered 'modified' in general");Y.Assert.isTrue(a.isModified({persistedOnly:true}),"The model now has a persisted attribute that is modified. This should return true.")},"If the persistedOnly option is provided as true and a specific attribute name is given, isModified() should return true only if the attribute is both modified, and persisted":function(){var b=Data.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]});var a=new b();Y.Assert.isFalse(a.isModified("persistedAttr"),"Initial condition: the 'persistedAttr' should not be considered modified");Y.Assert.isFalse(a.isModified("unpersistedAttr"),"Initial condition: the 'unpersistedAttr' should not be considered modified");a.set("unpersistedAttr","value1");Y.Assert.isTrue(a.isModified("unpersistedAttr"),"The 'unpersistedAttr' should be considered 'modified' in general");Y.Assert.isFalse(a.isModified("unpersistedAttr",{persistedOnly:true}),"The 'unpersistedAttr' is not persisted, so this call should return false, even though it has been changed");a.set("persistedAttr","value1");Y.Assert.isTrue(a.isModified("persistedAttr"),"The 'persistedAttr' should still be considered 'modified' in general");Y.Assert.isTrue(a.isModified("persistedAttr",{persistedOnly:true}),"The 'persistedAttr' is both modified, and persisted. This should return true.")}},{name:"Test getData()",setUp:function(){this.origNativeObjectConverter=Data.data.NativeObjectConverter;var a=this.args={};Data.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}}},tearDown:function(){Data.data.NativeObjectConverter=this.origNativeObjectConverter},"getData() should delegate to the singleton NativeObjectConverter to create an Object representation of its data":function(){var d=Data.Model.extend({attributes:["attr1","attr2"]});var b=new d({attr1:"value1",attr2:"value2"});var c={raw:true};var a=b.getData(c);Y.Assert.areSame(b,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the model.");Y.Assert.areSame(c,this.args[1],"The second arg provided to NativeObjectConverter::convert() should have been the options object")}},{name:"Test getChanges()",setUp:function(){this.origNativeObjectConverter=Data.data.NativeObjectConverter;var a=this.args={};Data.data.NativeObjectConverter={convert:function(){a[0]=arguments[0];a[1]=arguments[1]}};this.ConcreteDataComponentAttribute=Data.attribute.DataComponentAttribute.extend({});this.ConcreteDataComponent=Data.DataComponent.extend({getData:Data.emptyFn,isModified:Data.emptyFn,commit:Data.emptyFn,rollback:Data.emptyFn})},tearDown:function(){Data.data.NativeObjectConverter=this.origNativeObjectConverter},"getChanges() should delegate to the singleton NativeObjectConverter to create an Object representation of its data, but only provide changed attributes for the attributes that should be returned":function(){var e=Data.Model.extend({attributes:["attr1","attr2","attr3",new this.ConcreteDataComponentAttribute({name:"nestedDataComponent",embedded:false}),new this.ConcreteDataComponentAttribute({name:"embeddedDataComponent",embedded:true})]});var c=JsMockito.mock(this.ConcreteDataComponent);JsMockito.when(c).isModified().thenReturn(true);var b=new e({attr1:"value1",attr2:"value2",attr3:"value3",nestedDataComponent:c,embeddedDataComponent:c});b.set("attr1","newValue1");b.set("attr2","newValue2");var a=b.getChanges({raw:true});var d=this.args[1];Y.Assert.areSame(b,this.args[0],"The first arg provided to NativeObjectConverter::convert() should have been the model.");Y.Assert.areSame(true,d.raw,"The second arg provided to NativeObjectConverter::convert() should have receieved the 'raw:true' option");Y.ArrayAssert.itemsAreSame(["attr1","attr2","embeddedDataComponent"],d.attributeNames,"The second arg provided to NativeObjectConverter::convert() should have receieved the 'attributeNames' option, with the attributes that were changed")}},{name:"Test commit()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]});this.ConcreteDataComponent=Data.DataComponent.extend({getData:Data.emptyFn,isModified:Data.emptyFn,commit:Data.emptyFn,rollback:Data.emptyFn})},"committing changed data should cause the 'dirty' flag to be reset to false, and getChanges() to return an empty object":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();var b=a.getChanges();Y.Assert.areSame(0,_.keys(b).length,"The changes hash retrieved should have exactly 0 properties");Y.Assert.isFalse(a.isDirty(),"The model should no longer be marked as 'dirty'")},"committing changed data should cause rollback() to have no effect":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.commit();a.rollback();Y.Assert.areSame("new value 1",a.get("attribute1"),"attribute1 should have been 'new value 1'. rollback() should not have had any effect.");Y.Assert.areSame("new value 2",a.get("attribute2"),"attribute2 should have been 'new value 2'. rollback() should not have had any effect.")},"committing changed data should fire the 'commit' event":function(){var a=0;var b=new this.TestModel();b.addListener("commit",function(){a++});b.set("attribute1","new value 1");b.set("attribute2","new value 2");b.commit();Y.Assert.areSame(1,a,"The 'commit' event should have been fired exactly once after committing.")},"committing a parent model should also commit any embedded child DataComponent that the model holds":function(){var e=Data.attribute.DataComponentAttribute.extend({getData:Data.emptyFn,isModified:Data.emptyFn,commit:Data.emptyFn,rollback:Data.emptyFn});var d=Data.Model.extend({attributes:[new e({name:"childDataComponent",embedded:true})]});var c=JsMockito.mock(this.ConcreteDataComponent);var a=new d();a.set("childDataComponent",c);a.commit();try{JsMockito.verify(c).commit()}catch(b){Y.Assert.fail(b)}}},{name:"Test rollback()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},"rollback() should revert the model's values back to default values if before any committed set() calls":function(){var a=new this.TestModel();a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.isUndefined(a.get("attribute1"));Y.Assert.areSame("attribute2's default",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should revert the model's values back to their pre-set() values, when more than one set() call is made":function(){var a=new this.TestModel({attribute1:"original attribute1",attribute2:"original attribute2"});a.set("attribute1","new value 1");a.set("attribute2","new value 2");a.set("attribute1","new value 1 - even newer");a.set("attribute2","new value 2 - even newer");Y.Assert.isTrue(a.isDirty(),"The 'dirty' flag should be true.");a.rollback();Y.Assert.areSame("original attribute1",a.get("attribute1"));Y.Assert.areSame("original attribute2",a.get("attribute2"));Y.Assert.isFalse(a.isDirty(),"The 'dirty' flag should be false after rollback.")},"rollback() should fire the 'rollback' event":function(){var b=0;var a=new this.TestModel({attribute1:"orig1",attribute2:"orig2"});a.on("rollback",function(){b++});a.set("attribute1","new1");Y.Assert.areSame(0,b,"Initial condition: The rollback event should not have been fired yet");a.rollback();Y.Assert.areSame(1,b,"The rollback event should have been fired exactly once")}},{name:"Test reload()",setUp:function(){this.TestModel=Class.extend(Data.Model,{addAttributes:[{name:"attribute1"},{name:"attribute2",defaultValue:"attribute2's default"},{name:"attribute3",defaultValue:function(){return"attribute3's default"}},{name:"attribute4",set:function(a){return this.get("attribute1")+" "+this.get("attribute2")}},{name:"attribute5",set:function(a){return a+" "+this.get("attribute2")}}]})},_should:{error:{"reload() should throw an error if there is no configured persistenceProxy":"Data.Model::reload() error: Cannot load. No persistenceProxy."}},"reload() should throw an error if there is no configured persistenceProxy":function(){var a=new this.TestModel({});a.reload();Y.Assert.fail("reload() should have thrown an error with no configured persistenceProxy")},"reload() should delegate to its persistenceProxy's read() method to retrieve the data":function(){var b=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));var d=this.TestModel.extend({persistenceProxy:b});var a=new d();a.reload();try{JsMockito.verify(b).read()}catch(c){Y.Assert.fail(c)}}},{name:"Test save()",ttype:"testsuite",items:[{name:"General save() tests",setUp:function(){this.proxy=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}))},_should:{error:{"save() should throw an error if there is no configured persistenceProxy":"Data.Model::save() error: Cannot save. No persistenceProxy."}},"save() should throw an error if there is no configured persistenceProxy":function(){var b=Data.Model.extend({});var a=new b();a.save();Y.Assert.fail("save() should have thrown an error with no configured persistenceProxy")},"save() should delegate to its persistenceProxy's create() method to persist changes when the Model does not have an id set":function(){var c=Data.Model.extend({addAttributes:["id"],idAttribute:"id",persistenceProxy:this.proxy});var a=new c();a.save();try{JsMockito.verify(this.proxy).create()}catch(b){Y.Assert.fail(b)}},"save() should delegate to its persistenceProxy's update() method to persist changes, when the Model has an id":function(){var c=Data.Model.extend({addAttributes:["id"],idAttribute:"id",persistenceProxy:this.proxy});var a=new c({id:1});a.save();try{JsMockito.verify(this.proxy).update()}catch(b){Y.Assert.fail(b)}}},{name:"save() callbacks and promise tests",setUp:function(){this.proxy=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));this.Model=Data.Model.extend({addAttributes:["id","attribute1"],persistenceProxy:this.proxy})},"save should call its 'success' and 'complete' callbacks if the persistenceProxy successfully creates":function(){this.proxy.create=function(e,d){if(d.success){d.success.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model();b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error while creating":function(){this.proxy.create=function(e,d){if(d.error){d.error.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model();b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'success' and 'complete' callbacks if the persistenceProxy successfully updates":function(){this.proxy.update=function(e,d){if(d.success){d.success.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model({id:1});b.save({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error while updating":function(){this.proxy.update=function(e,d){if(d.error){d.error.call(d.scope||window)}if(d.complete){d.complete(d.scope||window)}};var c=0,a=0;var b=new this.Model({id:1});b.save({error:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `done` and `always` callbacks executed when the persistenceProxy successfully creates":function(){this.proxy.create=function(g,f){if(f.success){f.success.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model();var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(1,c,"The 'done' function should have been called exactly once");Y.Assert.areSame(0,a,"The 'fail' function should not have been called");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `fail` and `always` callbacks executed when the persistenceProxy fails to create":function(){this.proxy.create=function(g,f){if(f.error){f.error.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model();var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(0,c,"The 'done' function should not have been called");Y.Assert.areSame(1,a,"The 'fail' function should have been called exactly once");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `done` and `always` callbacks executed when the persistenceProxy successfully updates":function(){this.proxy.update=function(g,f){if(f.success){f.success.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model({id:1});var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(1,c,"The 'done' function should have been called exactly once");Y.Assert.areSame(0,a,"The 'fail' function should not have been called");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"save should return a jQuery.Promise object which has its `fail` and `always` callbacks executed when the persistenceProxy fails to update":function(){this.proxy.update=function(g,f){if(f.error){f.error.call(f.scope||window)}if(f.complete){f.complete(f.scope||window)}};var c=0,a=0,d=0;var b=new this.Model({id:1});var e=b.save().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(0,c,"The 'done' function should not have been called");Y.Assert.areSame(1,a,"The 'fail' function should have been called exactly once");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")}},{name:"Test basic persistence",setUp:function(){this.Model=Data.Model.extend({addAttributes:["id","attribute1","attribute2"]})},"Model attributes that have been persisted should not be persisted again if they haven't changed since the last persist":function(){var b;var c=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));JsMockito.when(c).update().then(function(f,e){b=f.getChanges();e.success.call(e.scope)});var d=this.Model.extend({persistenceProxy:c});var a=new d({id:1});a.set("attribute1","newattribute1value");a.save();Y.Assert.areSame(1,_.keys(b).length,"The dataToPersist should only have one key after attribute1 has been changed");Y.ObjectAssert.ownsKeys(["attribute1"],b,"The dataToPersist should have 'attribute1'");a.set("attribute2","newattribute2value");a.save();Y.Assert.areSame(1,_.keys(b).length,"The dataToPersist should only have one key after attribute2 has been changed");Y.ObjectAssert.ownsKeys(["attribute2"],b,"The dataToPersist should have 'attribute2'")}},{name:"Test concurrent persistence and model updates",createModel:function(b){var a=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));JsMockito.when(a).update().then(function(d,c){window.setTimeout(function(){c.success.call(c.scope||window)},b)});return Data.Model.extend({addAttributes:["id","attribute1","attribute2"],persistenceProxy:a})},"Model attributes that are updated (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var b=this.createModel(50),a=new b({id:1});a.set("attribute1","origValue1");a.set("attribute2","origValue2");a.save({success:function(){c.resume(function(){Y.Assert.isTrue(a.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue1",a.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",a.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.")})}});a.set("attribute1","newValue1");c.wait(100)},"Model attributes that are updated *more than once* (via set()) while a persistence request is in progress should not be marked as committed when the persistence request completes":function(){var c=this;var b=this.createModel(50),a=new b({id:1});a.set("attribute1","origValue1");a.set("attribute2","origValue2");a.save({success:function(){c.resume(function(){Y.Assert.isTrue(a.isDirty(),"The model should still be dirty after the persistence operation. attribute1 was set after the persistence operation began.");Y.Assert.isTrue(a.isModified("attribute1"),"attribute1 should be marked as modified (dirty). It was updated (set) after the persistence operation began.");Y.Assert.isFalse(a.isModified("attribute2"),"attribute2 should not be marked as modified. It was not updated after the persistence operation began.");Y.Assert.areSame("newValue11",a.get("attribute1"),"a get() operation on attribute1 should return the new value.");Y.Assert.areSame("origValue2",a.get("attribute2"),"a get() operation on attribute2 should return the persisted value. It was not updated since the persistence operation began.");a.rollback();Y.Assert.areSame("origValue1",a.get("attribute1"),"The value for attribute1 should have been rolled back to its original value")})}});a.set("attribute1","newValue1");a.set("attribute1","newValue11");c.wait(100)}},{name:"Test save() with related Collections that need to be sync'd first",setUp:function(){this.proxy=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));this.Model=Data.Model.extend({attributes:[{name:"attr",type:"string"},{name:"c1",type:"collection"},{name:"c2",type:"collection"}],persistenceProxy:this.proxy});this.collection1=JsMockito.mock(Data.Collection);JsMockito.when(this.collection1).getModels().thenReturn([]);this.collection2=JsMockito.mock(Data.Collection);JsMockito.when(this.collection2).getModels().thenReturn([])},"save() should synchronize any nested 'related' (as opposed to 'embedded') collections before synchronizing itself":function(){var k=0,c=0,i=0,d=0;JsMockito.when(this.collection1).sync().then(function(){k++;var m=new jQuery.Deferred();m.done(function(){i++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.collection2).sync().then(function(){c++;var m=new jQuery.Deferred();m.done(function(){d++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.proxy).create().then(function(n,m){setTimeout(function(){m.success.call(m.scope)},25)});var g=new this.Model({attr:"attrValue",c1:this.collection1,c2:this.collection2});var h=0,l=0,j=0,b=0,a=0,e=0;var f=g.save({success:function(){h++},error:function(){l++},complete:function(){j++}});f.done(function(){b++}).fail(function(){a++}).always(function(){e++});Y.Assert.areSame(1,k,"sync() should have been called on collection1");Y.Assert.areSame(1,c,"sync() should have been called on collection2");Y.Assert.areSame(0,i,"collection1's sync should not yet be done");Y.Assert.areSame(0,d,"collection2's sync should not yet be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet");this.wait(function(){Y.Assert.areSame(1,i,"collection1's sync should now be done");Y.Assert.areSame(1,d,"collection2's sync should now be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet (2)");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet (2)");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet (2)");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet (2)");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet (2)");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet (2)");this.wait(function(){Y.Assert.areSame(1,h,"`complete` callback should have been called");Y.Assert.areSame(0,l,"`error` callback should NOT have been called");Y.Assert.areSame(1,j,"`complete` callback should have been called");Y.Assert.areSame(1,b,"`done` callback should have been called");Y.Assert.areSame(0,a,"`fail` callback should NOT have been called");Y.Assert.areSame(1,e,"`always` callback should have been called")},50)},75)},"save() should call the 'error' and 'fail' callbacks if a collection fails to synchronize":function(){var k=0,d=0,i=0,b=0;JsMockito.when(this.collection1).sync().then(function(){k++;var m=new jQuery.Deferred();m.done(function(){i++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.collection2).sync().then(function(){d++;var m=new jQuery.Deferred();m.fail(function(){b++});setTimeout(function(){m.reject()},50);return m});JsMockito.when(this.proxy).create().then(function(n,m){setTimeout(function(){m.success.call(m.scope)},25)});var g=new this.Model({attr:"attrValue",c1:this.collection1,c2:this.collection2});var h=0,l=0,j=0,c=0,a=0,e=0;var f=g.save({success:function(){h++},error:function(){l++},complete:function(){j++}});f.done(function(){c++}).fail(function(){a++}).always(function(){e++});Y.Assert.areSame(1,k,"sync() should have been called on collection1");Y.Assert.areSame(1,d,"sync() should have been called on collection2");Y.Assert.areSame(0,i,"collection1's sync should not yet be done");Y.Assert.areSame(0,b,"collection2's sync should not yet be failed");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet");Y.Assert.areSame(0,c,"Shouldn't have any done calls yet");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet");this.wait(function(){Y.Assert.areSame(1,i,"collection1's sync should now be done");Y.Assert.areSame(1,b,"collection2's sync should now be failed");Y.Assert.areSame(0,h,"`complete` callback NOT should have been called");Y.Assert.areSame(1,l,"`error` callback should have been called");Y.Assert.areSame(1,j,"`complete` callback should have been called");Y.Assert.areSame(0,c,"`done` callback should NOT have been called");Y.Assert.areSame(1,a,"`fail` callback should have been called");Y.Assert.areSame(1,e,"`always` callback should have been called")},75)},"save() should call the 'error' and 'fail' callbacks if collections synchronize, but the model itself fails to save":function(){var k=0,c=0,i=0,d=0;JsMockito.when(this.collection1).sync().then(function(){k++;var m=new jQuery.Deferred();m.done(function(){i++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.collection2).sync().then(function(){c++;var m=new jQuery.Deferred();m.done(function(){d++});setTimeout(function(){m.resolve()},50);return m});JsMockito.when(this.proxy).create().then(function(n,m){setTimeout(function(){m.error.call(m.scope)},25)});var g=new this.Model({attr:"attrValue",c1:this.collection1,c2:this.collection2});var h=0,l=0,j=0,b=0,a=0,e=0;var f=g.save({success:function(){h++},error:function(){l++},complete:function(){j++}});f.done(function(){b++}).fail(function(){a++}).always(function(){e++});Y.Assert.areSame(1,k,"sync() should have been called on collection1");Y.Assert.areSame(1,c,"sync() should have been called on collection2");Y.Assert.areSame(0,i,"collection1's sync should not yet be done");Y.Assert.areSame(0,d,"collection2's sync should not yet be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet");this.wait(function(){Y.Assert.areSame(1,i,"collection1's sync should now be done");Y.Assert.areSame(1,d,"collection2's sync should now be done");Y.Assert.areSame(0,h,"Shouldn't have any success calls yet (2)");Y.Assert.areSame(0,l,"Shouldn't have any error calls yet (2)");Y.Assert.areSame(0,j,"Shouldn't have any complete calls yet (2)");Y.Assert.areSame(0,b,"Shouldn't have any done calls yet (2)");Y.Assert.areSame(0,a,"Shouldn't have any fail calls yet (2)");Y.Assert.areSame(0,e,"Shouldn't have any always calls yet (2)");this.wait(function(){Y.Assert.areSame(0,h,"`complete` callback NOT should have been called");Y.Assert.areSame(1,l,"`error` callback should have been called");Y.Assert.areSame(1,j,"`complete` callback should have been called");Y.Assert.areSame(0,b,"`done` callback should NOT have been called");Y.Assert.areSame(1,a,"`fail` callback should have been called");Y.Assert.areSame(1,e,"`always` callback should have been called")},50)},75)}}]},{name:"Test destroy()",ttype:"testsuite",items:[{name:"General destroy() tests",_should:{error:{"destroy() should throw an error if there is no configured persistenceProxy when it tries to destroy a model that has been persisted (i.e. has an id)":"Data.Model::destroy() error: Cannot destroy model on server. No persistenceProxy."}},"destroy() should throw an error if there is no configured persistenceProxy when it tries to destroy a model that has been persisted (i.e. has an id)":function(){var b=Data.Model.extend({addAttributes:["id","attribute1","attribute2"]});var a=new b({id:1});a.destroy();Y.Assert.fail("destroy() should have thrown an error with no configured persistenceProxy")},"destroy() should delegate to its persistenceProxy's destroy() method to persist the destruction of the model":function(){var b=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));var d=Data.Model.extend({attributes:["id"],persistenceProxy:b});var a=new d({id:1});a.destroy();try{JsMockito.verify(b).destroy()}catch(c){Y.Assert.fail("The model should have delegated to the destroy method exactly once.")}},"upon successful destruction of the Model, the Model should fire its 'destroy' event":function(){var b=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}));JsMockito.when(b).destroy().then(function(f,e){e.success.call(e.scope)});var d=Data.Model.extend({attributes:["id"],persistenceProxy:b});var a=new d({id:1});var c=false;a.addListener("destroy",function(){c=true});a.destroy();Y.Assert.isTrue(c,"Should have fired its destroy event")}},{name:"destroy() callbacks and returned promise tests",setUp:function(){this.proxy=JsMockito.mock(Data.persistence.Proxy.extend({create:Data.emptyFn,read:Data.emptyFn,update:Data.emptyFn,destroy:Data.emptyFn}))},"destroy() should call its 'success' and 'complete' callbacks if the persistenceProxy is successful":function(){var c=0,a=0;JsMockito.when(this.proxy).destroy().then(function(f,e){if(e.success){e.success.call(e.scope)}});var d=Data.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new d({id:1});b.destroy({success:function(){c++},complete:function(){a++},scope:this});Y.Assert.areSame(1,c,"The 'success' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"destroy() should call its 'error' and 'complete' callbacks if the persistenceProxy encounters an error":function(){var d=0,a=0;JsMockito.when(this.proxy).destroy().then(function(f,e){e.error.call(e.scope)});var c=Data.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new c({id:1});b.destroy({error:function(){d++},complete:function(){a++},scope:this});Y.Assert.areSame(1,d,"The 'error' function should have been called exactly once");Y.Assert.areSame(1,a,"The 'complete' function should have been called exactly once")},"destroy() should return a jQuery.Promise object, which has its `done` and `always` callbacks executed upon successful completion":function(){var c=0,a=0,d=0;JsMockito.when(this.proxy).destroy().then(function(h,g){g.success.call(g.scope)});var f=Data.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new f({id:1});var e=b.destroy().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(1,c,"The 'done' function should have been called exactly once");Y.Assert.areSame(0,a,"The 'fail' function should have not been called");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")},"destroy() should return a jQuery.Promise object, which has its `fail` and `always` callbacks executed upon an error while persisting":function(){var c=0,a=0,d=0;JsMockito.when(this.proxy).destroy().then(function(h,g){g.error.call(g.scope)});var f=Data.Model.extend({attributes:["id"],persistenceProxy:this.proxy});var b=new f({id:1});var e=b.destroy().done(function(){c++}).fail(function(){a++}).always(function(){d++});Y.Assert.areSame(0,c,"The 'done' function should not have been called");Y.Assert.areSame(1,a,"The 'fail' function should have been called exactly once");Y.Assert.areSame(1,d,"The 'always' function should have been called exactly once")}}]}]}));tests.unit.persistence.add(new Ext.test.TestSuite({name:"Data.persistence.RestProxy",items:[{name:"Test create",ttype:"testsuite",items:[{name:"General create() tests","create() should populate the model with any response data upon a successful ajax request":function(){var c={attribute1:"value1",attribute2:"value2"};var d=Data.persistence.RestProxy.extend({ajax:function(e){e.success(c)}});var b=new d();var a=JsMockito.mock(Data.Model);b.create(a);try{JsMockito.verify(a).set(c)}catch(f){Y.Assert.fail("The model should have had its data set to the testData")}}},{name:"create()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'POST'":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.create(b);Y.Assert.areSame("POST",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{create:"PUT"}});var c=new d();c.create(b);Y.Assert.areSame("PUT",a)}}]},{name:"Test read",ttype:"testsuite",items:[{name:"General read() tests","read() should populate the model data upon a successful ajax request":function(){var c={attribute1:"value1",attribute2:"value2"};var d=Data.persistence.RestProxy.extend({ajax:function(e){e.success(c)}});var b=new d();var a=JsMockito.mock(Data.Model);b.read(a);try{JsMockito.verify(a).set(c)}catch(f){Y.Assert.fail("The model should have had its data set to the testData")}}},{name:"read()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'GET'":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.read(b);Y.Assert.areSame("GET",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{read:"POST"}});var c=new d();c.read(b);Y.Assert.areSame("POST",a)}}]},{name:"Test update()",ttype:"testsuite",items:[{name:"General update() tests","update() should NOT actually call the ajax method when no attributes have been changed":function(){var a=0;var d=Data.persistence.RestProxy.extend({ajax:function(){a++}});var c=new d();var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({});c.update(b);Y.Assert.areSame(0,a,"The proxy's ajax() method should not have not been called, since there are no changes")},"update() should in fact call the ajax method when attributes have been changed":function(){var a=0;var d=Data.persistence.RestProxy.extend({ajax:function(){a++}});var c=new d();var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});c.update(b);Y.Assert.areSame(1,a,"The proxy's ajax() method should have been called, since there are changes to persist")}},{name:"Test update() callbacks",setUp:function(){this.ajaxCallCount=0;this.TestProxy=Data.persistence.RestProxy.extend({ajax:jQuery.proxy(function(a){this.ajaxCallCount++;if(a.success){a.success()}if(a.error){a.error()}if(a.complete){a.complete()}},this)})},"The 'success' and 'complete' callbacks provided to update() should be called if no attributes have been changed, and it does not need to do its ajax request":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({});var c=new this.TestProxy();var d=0,a=0;c.update(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(0,this.ajaxCallCount,"The ajax method should not have been called");Y.Assert.areSame(1,d,"The 'success' callback provided update() should have been called even though there are no changes and the proxy didn't need to persist anything");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called even though there are no changes and the proxy didn't need to persist anything")},"The 'success' and 'complete' callbacks provided to update() should be called if the ajax request is successful":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new this.TestProxy();var d=0,a=0;c.update(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'success' callback provided update() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called")},"The 'error' and 'complete' callbacks provided to update() should be called if the ajax request fails":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new this.TestProxy();var d=0,a=0;c.update(b,{error:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'error' callback provided update() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided update() should have been called")}},{name:"HTTP method tests","By default, the ajax function should be called with the HTTP method 'PUT'":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.update(b);Y.Assert.areSame("PUT",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{update:"POST"}});var c=new d();c.update(b);Y.Assert.areSame("POST",a)}},{name:"Test incremental updates",setUp:function(){this.mockModel=JsMockito.mock(Data.Model);JsMockito.when(this.mockModel).getData().thenReturn({attribute1:"value1",attribute2:"value2"});JsMockito.when(this.mockModel).getChanges().thenReturn({attribute2:"value2"})},"update() should provide the full set of data to the ajax method if the proxy is not set to do incremental updates":function(){var a;var d=function(e){a=JSON.parse(e.data)};var c=Data.persistence.RestProxy.extend({ajax:d,incremental:false});var b=new c();b.update(this.mockModel);Y.Assert.areEqual(2,_.keys(a).length,"The dataPersisted have exactly 2 keys, one for each of the attributes in the model");Y.ObjectAssert.ownsKeys(["attribute1","attribute2"],a);Y.Assert.areEqual("value1",a.attribute1);Y.Assert.areEqual("value2",a.attribute2)},"update() should provide only the changed data if the proxy is set to do incremental updates":function(){var a;var d=function(e){a=JSON.parse(e.data)};var c=Data.persistence.RestProxy.extend({ajax:d,incremental:true});var b=new c();b.update(this.mockModel);Y.Assert.areEqual(1,_.keys(a).length,"The dataPersisted have exactly 1 key, the one that was changed");Y.ObjectAssert.ownsKeys(["attribute2"],a);Y.Assert.areEqual("value2",a.attribute2)}}]},{name:"Test destroy",ttype:"testsuite",items:[{name:"Test destroy()'s callbacks","The 'success' and 'complete' callbacks provided to destroy() should be called if the ajax request is successful":function(){var f=function(g){g.success();g.complete()};var e=Class.extend(Data.persistence.RestProxy,{ajax:f});var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new e();var d=0,a=0;c.destroy(b,{success:function(){d++},complete:function(){a++}});Y.Assert.areSame(1,d,"The 'success' callback provided destroy() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided destroy() should have been called")},"The 'error' and 'complete' callbacks provided to destroy() should be called if the ajax request fails":function(){var e=function(g){g.error();g.complete()};var d=Class.extend(Data.persistence.RestProxy,{ajax:e});var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var c=new d();var f=0,a=0;c.destroy(b,{error:function(){f++},complete:function(){a++}});Y.Assert.areSame(1,f,"The 'error' callback provided destroy() should have been called");Y.Assert.areSame(1,a,"The 'complete' callback provided destroy() should have been called")}},{name:"destroy()'s HTTP method tests","By default, the ajax function should be called with the HTTP method 'DELETE'":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type}});var c=new d();c.destroy(b);Y.Assert.areSame("DELETE",a)},"The HTTP method should be overridable via the actionMethods config":function(){var b=JsMockito.mock(Data.Model);JsMockito.when(b).getChanges().thenReturn({attribute1:"value1"});var a="";var d=Class.extend(Data.persistence.RestProxy,{ajax:function(e){a=e.type},actionMethods:{destroy:"POST"}});var c=new d();c.destroy(b);Y.Assert.areSame("POST",a)}}]},{name:"Test buildUrl()","buildUrl() should handle a urlRoot without a trailing slash":function(){var a=JsMockito.mock(Data.Model);JsMockito.when(a).getId().thenReturn(42);var b=new Data.persistence.RestProxy({urlRoot:"/testUrl",appendId:false});Y.Assert.areSame("/testUrl",b.buildUrl(a,"create"),"buildUrl() should have returned the urlRoot when doing a 'create'");Y.Assert.areSame("/testUrl/42",b.buildUrl(a,"read"),"buildUrl() should have appended the ID when doing a 'read'");Y.Assert.areSame("/testUrl/42",b.buildUrl(a,"update"),"buildUrl() should have appended the ID when doing a 'update'");Y.Assert.areSame("/testUrl/42",b.buildUrl(a,"delete"),"buildUrl() should have appended the ID when doing a 'delete'")},"buildUrl() should handle a urlRoot with a trailing slash":function(){var a=JsMockito.mock(Data.Model);JsMockito.when(a).getId().thenReturn(42);var b=new Data.persistence.RestProxy({urlRoot:"/testUrl/",appendId:false});Y.Assert.areSame("/testUrl/",b.buildUrl(a,"create"),"buildUrl() should have returned the urlRoot when doing a 'create'");Y.Assert.areSame("/testUrl/42",b.buildUrl(a,"read"),"buildUrl() should have appended the ID when doing a 'read'");Y.Assert.areSame("/testUrl/42",b.buildUrl(a,"update"),"buildUrl() should have appended the ID when doing a 'update'");Y.Assert.areSame("/testUrl/42",b.buildUrl(a,"delete"),"buildUrl() should have appended the ID when doing a 'delete'")}}]}));(function(){tests.integration=new Ext.test.TestSuite("integration");tests.integration.persistence=new Ext.test.TestSuite("persistence").addTo(tests.integration);Ext.test.Session.addSuite(tests.integration)})();tests.integration.add(new Ext.test.TestSuite({name:"Collection with Models",items:[{name:"Test Model Events","changing an attribute in a model should fire a general 'change' event in the Collection":function(){var e=Data.Model.extend({attributes:["attr"]});var f=Data.Collection.extend({model:e});var k=new e({attr:"model1Value1"}),j=new e({attr:"model2Value1"}),g=new f([k,j]);var b=0,d,a,i,h,c;g.on("change",function(p,n,m,o,l){b++;d=p;a=n;i=m;h=o;c=l});k.set("attr","model1Value2");Y.Assert.areSame(1,b,"The call count should now be exactly 1");Y.Assert.areSame(g,d,"The event for model1 should have been fired with the collection that changed");Y.Assert.areSame(k,a,"The event for model1 should have been fired with the model that changed");Y.Assert.areSame("attr",i,"The event for model1 should have been fired with the correct attribute name");Y.Assert.areSame("model1Value2",h,"The event for model1 should have been fired with the new value");Y.Assert.areSame("model1Value1",c,"The event for model1 should have been fired with the old value");j.set("attr","model2Value2");Y.Assert.areSame(2,b,"The call count should now be exactly 2");Y.Assert.areSame(g,d,"The event for model2 should have been fired with the collection that changed");Y.Assert.areSame(j,a,"The event for model2 should have been fired with the model that changed");Y.Assert.areSame("attr",i,"The event for model2 should have been fired with the correct attribute name");Y.Assert.areSame("model2Value2",h,"The event for model2 should have been fired with the new value");Y.Assert.areSame("model2Value1",c,"The event for model2 should have been fired with the old value")},"changing an attribute in a model should fire an attribute-specific 'change' event in the Collection":function(){var e=Data.Model.extend({attributes:["attr"]});var f=Data.Collection.extend({model:e});var j=new e({attr:"model1Value1"}),i=new e({attr:"model2Value1"}),g=new f([j,i]);var b=0,d,a,h,c;g.on("change:attr",function(n,l,m,k){b++;d=n;a=l;h=m;c=k});j.set("attr","model1Value2");Y.Assert.areSame(1,b,"The call count should now be exactly 1");Y.Assert.areSame(g,d,"The event for model1 should have been fired with the collection that changed");Y.Assert.areSame(j,a,"The event for model1 should have been fired with the model that changed");Y.Assert.areSame("model1Value2",h,"The event for model1 should have been fired with the new value");Y.Assert.areSame("model1Value1",c,"The event for model1 should have been fired with the old value");i.set("attr","model2Value2");Y.Assert.areSame(2,b,"The call count should now be exactly 2");Y.Assert.areSame(g,d,"The event for model2 should have been fired with the collection that changed");Y.Assert.areSame(i,a,"The event for model2 should have been fired with the model that changed");Y.Assert.areSame("model2Value2",h,"The event for model2 should have been fired with the new value");Y.Assert.areSame("model2Value1",c,"The event for model2 should have been fired with the old value")},"Any event that the Model fires should be relayed by the Collection":function(){var b=Data.Model.extend({initialize:function(){this.addEvents("testevent")},attributes:["attr"]});var f=Data.Collection.extend({model:b});var k=new b(),j=new b(),h=new f([k,j]);var c=0,g,i,e,d,a;h.on("testevent",function(p,o,n,m,l){c++;g=p;i=o;e=n;d=m;a=l});k.fireEvent("testevent",k,1,2,3);Y.Assert.areSame(1,c,"The testevent should have been called exactly once");Y.Assert.areSame(h,g,"The testevent should have been called with the collection (as it was provided)");Y.Assert.areSame(k,i,"The testevent should have been called with the model (as it was provided)");Y.Assert.areSame(1,e,"arg1 should have been provided");Y.Assert.areSame(2,d,"arg2 should have been provided");Y.Assert.areSame(3,a,"arg3 should have been provided")},"After a model has been removed from the Collection, the collection should no longer relay its events":function(){var e=Data.Model.extend({initialize:function(){this.addEvents("testevent")},attributes:["attr"]});var a=Data.Collection.extend({model:e});var f=new e(),d=new e(),c=new a([f,d]);var b=0;c.on("testevent",function(){b++});c.remove(f);f.fireEvent("testevent");Y.Assert.areSame(0,b,"The testevent should *not* have been fired from the collection, as the child model was removed")}},{name:"Test isModified()",setUp:function(){this.Model=Data.Model.extend({attributes:[{name:"attr"},{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]});this.Collection=Data.Collection.extend({model:this.Model})},"isModified() should return false if no Models within the collection have been modified":function(){var c=new this.Model({attr:1}),b=new this.Model({attr:2}),a=new this.Collection([c,b]);Y.Assert.isFalse(a.isModified())},"isModified() should return true if a Model within the collection has been modified":function(){var c=new this.Model({attr:1}),b=new this.Model({attr:2}),a=new this.Collection([c,b]);c.set("attr",42);Y.Assert.isTrue(a.isModified())},"isModified() should return false if a Model within the collection has been modified, but then rolled back or committed":function(){var c=new this.Model({attr:1}),b=new this.Model({attr:2}),a=new this.Collection([c,b]);c.set("attr",42);Y.Assert.isTrue(a.isModified(),"Just double checking that the collection is considered modified, before rolling back");c.rollback();Y.Assert.isFalse(a.isModified(),"Should be false after rollback");c.set("attr",42);Y.Assert.isTrue(a.isModified(),"Just double checking that the collection is considered modified again, before committing");c.commit();Y.Assert.isFalse(a.isModified(),"Should be false after commit")},"With the 'persistedOnly' option, isModified() should only return true if one of its models has a persisted attribute that has been changed":function(){var c=new this.Model(),b=new this.Model(),a=new this.Collection([c,b]);Y.Assert.isFalse(a.isModified(),"Initial condition: the collection should not be considered modified");Y.Assert.isFalse(a.isModified({persistedOnly:true}),"Initial condition: the collection should not be considered modified with the 'persistedOnly' option set");b.set("persistedAttr","newValue");Y.Assert.isTrue(a.isModified({persistedOnly:true}),"The collection should now be considered modified, as it has a model with a persisted attribute that has been modified")},"With the 'persistedOnly' option, isModified() should return false if none of its models have a persisted attribute that has been changed":function(){var c=new this.Model(),b=new this.Model(),a=new this.Collection([c,b]);Y.Assert.isFalse(a.isModified(),"Initial condition: the collection should not be considered modified");Y.Assert.isFalse(a.isModified({persistedOnly:true}),"Initial condition: the collection should not be considered modified with the 'persistedOnly' option set");b.set("unpersistedAttr","newValue");Y.Assert.isFalse(a.isModified({persistedOnly:true}),"The collection should *not* be considered modified, as its models only have unpersisted attribute changes")}},{name:"Test destroying a model. It should be removed from the collection.","When a model is destroyed, it should be removed from the collection. The collection should also fire the 'remove' event":function(){var f=0;var d=Data.Model.extend({attributes:["attr"]});var a=Data.Collection.extend({model:d});var e=new d({attr:1}),c=new d({attr:2}),b=new a([e,c]);b.on("remove",function(){f++});Y.Assert.isTrue(b.has(e),"Initial condition: the collection should have model1");e.destroy();Y.Assert.isFalse(b.has(e),"model1 should have been removed from the collection upon destruction");Y.Assert.areSame(1,f,"The 'remove' event should have been fired exactly once by the Collection")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ModelAttribute",items:[{name:"Test provided set() function","The set() function provided to a ModelAttribute should be passed the instantiated Model if a 'modelClass' config is provided":function(){var d;var b=Data.Model.extend({attributes:["someAttr"]});var c=Data.Model.extend({attributes:[{name:"attr",type:"model",modelClass:b,set:function(e){d=e;return e}}]});var a=new c({attr:{someAttr:1}});Y.Assert.isInstanceOf(b,d)}},{name:"Test retrieving the inner model from the outer model after it is set","The get() method should be able to retrieve the Model after it has been set":function(){var b=Data.Model.extend({attributes:["someValue"]});var d=Data.Model.extend({attributes:[{name:"innerModel",type:"model",modelClass:b}]});var a=new d({innerModel:{someValue:1}});var c=a.get("innerModel");Y.Assert.isInstanceOf(b,c)}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ModelCache",items:[{name:"Duplicate models should not be able to be instantiated","Instatiating two models of different types, but the same instance ID, should *not* be 'combined' into the same instance":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"id"});var a=Data.Model.extend({attributes:["id"],idAttribute:"id"});var d=new b({id:1});var c=new a({id:1});Y.Assert.areNotSame(d,c)},"Instatiating two models of the same type, but the different instance IDs, should *not* be 'combined' into the same instance":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b({id:1});var a=new b({id:2});Y.Assert.areNotSame(c,a)},"Instantiating two models of both the same type, and which have the same instance ID, should really become the same single instance (i.e. not duplicating it). The same reference should be returned when constructing the duplicate model":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b({id:1});var a=new b({id:1});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object")},"Instantiating one model and setting the ID later, then instantiating another with the same ID, the two models should point to the same instance":function(){var b=Data.Model.extend({attributes:["id"],idAttribute:"id"});var c=new b();c.set("id",1);var a=new b({id:1});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object")},"Instantiating two models with the same ID should combine the initial data, with still, only one actual instance should be created":function(){var b=Data.Model.extend({attributes:["id","firstName","lastName"],idAttribute:"id"});var c=new b({id:1,firstName:"Joe"});var a=new b({id:1,lastName:"Shmo"});Y.Assert.areSame(c,a,"model1 and model2 should point to the same object");Y.Assert.areSame("Joe",c.get("firstName"));Y.Assert.areSame("Shmo",c.get("lastName"))}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with NativeObjectConverter",items:[{name:"Test getData()",ttype:"suite",items:[{"Model::getData() should return a key for each of the Attributes in the Model, whether or not any data has been set to them":function(){var c=Data.Model.extend({addAttributes:["attribute1","attribute2"]});var a=new c({attribute1:"value1"});var b=a.getData();Y.ObjectAssert.hasKey("attribute1",b,"The data returned should have attribute1");Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.ObjectAssert.hasKey("attribute2",b,"The data returned should have attribute2, even though no value has been set to it");Y.Assert.isUndefined(b.attribute2,"attribute2 should be undefined in the returned data")},"Model::getData() should return the data by running attributes' `get` functions (not just returning the raw data), when the `raw` option is not provided":function(){var c=Data.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(d){return"42 "+this.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2"});var b=a.getData();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data")},"when the `raw` option is provided as true, Model::getData() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Data.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(d){return"42 "+this.get("attribute1")}},{name:"attribute3",raw:function(d){return d+" "+this.get("attribute1")}}]});var a=new c({attribute1:"value1",attribute2:"value2",attribute3:"value3"});var b=a.getData({raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned")},"Model::getData() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) with the `persistedOnly` option set to true":function(){var c=Data.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();var b=a.getData({persistedOnly:true});Y.Assert.areSame(2,_.keys(b).length,"The persisted data should only have 2 properties");Y.ObjectAssert.ownsKeys(["attribute1","attribute3"],b,"The persisted data should have 'attribute1' and 'attribute3'")}}]},{name:"Test getChanges()",ttype:"suite",items:[{"Model::getChanges() should return a single attribute that has had its value changed":function(){var c=Data.Model.extend({attributes:["attribute1","attribute2"]});var a=new c();a.set("attribute1","new value");var b=a.getChanges();Y.Assert.areSame(1,_.keys(b).length,"The changes hash retrieved should have exactly 1 property");Y.Assert.areSame("new value",b.attribute1,"The change to attribute1 should have been 'new value'.")},"Model::getChanges() should return multiple attributes that have had their values changed":function(){var c=Data.Model.extend({attributes:["attribute1","attribute2"]});var a=new c();a.set("attribute1","new value 1");a.set("attribute2","new value 2");var b=a.getChanges();Y.Assert.areSame(2,_.keys(b).length,"The changes hash retrieved should have exactly 2 properties");Y.Assert.areSame("new value 1",b.attribute1,"The change to attribute1 should have been 'new value 1'.");Y.Assert.areSame("new value 2",b.attribute2,"The change to attribute2 should have been 'new value 2'.")},"Model::getChanges() should return the data by running attributes' `get` functions (not just returning the raw data)":function(){var c=Data.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(d){return"42 "+this.get("attribute1")}},"attribute3"]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges();Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("42 value1",b.attribute2,"attribute2 should have had its `get` function run, and that used as the value in the data");Y.Assert.isFalse("attribute3" in b,"attribute3 should not exist in the 'changes' data, as it was never changed")},"when the `raw` option is provided as true, Model::getChanges() should return the data by running attributes' `raw` functions (not using `get`)":function(){var c=Data.Model.extend({addAttributes:["attribute1",{name:"attribute2",get:function(d){return"42 "+this.get("attribute1")}},{name:"attribute3",raw:function(d){return d+" "+this.get("attribute1")}},{name:"attribute4",defaultValue:"value4"}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");a.set("attribute3","value3");var b=a.getChanges({raw:true});Y.Assert.areSame("value1",b.attribute1,"attribute1 should be 'value1'");Y.Assert.areSame("value2",b.attribute2,"attribute2 should NOT have had its `get` function run. Its underlying data should have been returned");Y.Assert.areSame("value3 value1",b.attribute3,"attribute3 should have had its `raw` function run, and that value returned");Y.Assert.isFalse("attribute4" in b,"attribute4 should not exist in the 'changes' data, as it was never changed")},"Model::getChanges() should only retrieve the data for the persisted attributes (i.e. attributes with persist: true) that have been changed when the `persistedOnly` option is set to true":function(){var c=Data.Model.extend({addAttributes:[{name:"attribute1",persist:true},{name:"attribute2",persist:false},{name:"attribute3",persist:true},{name:"attribute4",persist:false}]});var a=new c();a.set("attribute1","value1");a.set("attribute2","value2");var b=a.getChanges({persistedOnly:true});Y.Assert.areSame(1,_.keys(b).length,"The persisted changes should only have 1 property");Y.ObjectAssert.ownsKeys(["attribute1"],b,"The persisted changes should only have 'attribute1'")}}]}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with Nested Collections",items:[{name:"Test default nested Collection initialization",_should:{ignore:{"A nested Collection attribute should default to be an empty collection":true}},"A nested Collection attribute should default to be an empty collection":function(){var b=Data.Model.extend({attributes:[{name:"nestedCollection",type:"collection"}]});var a=new b();Y.Assert.isInstanceOf(Data.Collection,a.get("nestedCollection"),"The 'nestedCollection' should have been an instance of Data.Collection");Y.Assert.areSame(0,a.get("nestedCollection").getCount(),"The 'nestedCollection' should be empty")}},{name:"Test setting nested Collections","set() should only change the attribute that a nested Collection is being set to if it is a different Collection than it already has":function(){var e=Data.Model.extend({attributes:[{name:"nestedCollection",type:"collection"}]});var f=Data.Collection.extend({});var a=new e();var c=new f();var b=new f();var d=0;a.addListener("change:nestedCollection",function(){d++});c.on("add",function(){});b.on("remove",function(){});a.set("nestedCollection",c);Y.Assert.areSame(1,d,"The collection should have been set for the first time");a.set("nestedCollection",c);Y.Assert.areSame(1,d,"The collection should not have been re-set, because it is the same collection that is already there");a.set("nestedCollection",b);Y.Assert.areSame(2,d,"The new collection (nestedCollection2) should have been set");a.set("nestedCollection",b);Y.Assert.areSame(2,d,"The new model (nestedModel2) should not have been re-set, because it is the same model that is already there");a.set("nestedCollection",null);Y.Assert.areSame(3,d,"The attribute should have been set to null");a.set("nestedCollection",c);Y.Assert.areSame(4,d,"The attribute should have been set to nestedCollection1 after it had been null")}},{name:"Test the 'change' event for nested collections","When an attribute has changed in a model of a nested collection, its parent collection should fire the appropriate 'change' events":function(){var d=Data.Model.extend({attributes:["attr"],toString:function(){return"(ChildModel)"}});var h=Data.Collection.extend({model:d,toString:function(){return"(Collection)"}});var l=Data.Model.extend({attributes:[{name:"myCollection",type:"Collection"}],toString:function(){return"(ParentModel)"}});var f=new d({attr:"origValue1"}),e=new d({attr:"origValue2"}),k=new h([f,e]),g=new l({myCollection:k});var b=Class({constructor:function(r,q,s,p){this.model=r;this.attributeName=q;this.newValue=s;this.oldValue=p}});var i=b.extend({constructor:function(t,r,q,s,p){this.collection=t;this._super([r,q,s,p])}});var a=0,n;g.on("change",function(r,q,s,p){a++;n=new b(r,q,s,p)});var m=0,j;g.on("change:myCollection",function(q,r,p){m++;j=new b(q,"",r,p)});var o=0,c;g.on("change:myCollection.*",function(t,r,q,s,p){o++;c=new i(t,r,q,s,p)});f.set("attr","newValue1");Y.Assert.areSame(1,a,"The call count should now be exactly 1");Y.Assert.areSame(g,n.model,"The event for childModel1 should have been fired with the parentModel");Y.Assert.areSame("myCollection",n.attributeName,"The event for childModel1 should have been fired with the correct attribute name");Y.Assert.areSame(k,n.newValue,"The event for childModel1 should have been fired with the newValue of the collection");Y.Assert.areSame(k,n.oldValue,"The event for childModel1 should have been fired with the oldValue of the collection");Y.Assert.areSame(1,m,"The call count should now be exactly 1");Y.Assert.areSame(g,j.model,"The attribute-specific event for childModel1 should have been fired with the parentModel");Y.Assert.areSame(k,j.newValue,"The attribute-specific event for childModel1 should have been fired with the newValue of the collection");Y.Assert.areSame(k,j.oldValue,"The attribute-specific event for childModel1 should have been fired with the oldValue of the collection");Y.Assert.areSame(1,o,"The call count should now be exactly 1");Y.Assert.areSame(k,c.collection,"The attribute-specific event for childModel1 should have been fired with the collection");Y.Assert.areSame(f,c.model,"The attribute-specific event for childModel1 should have been fired with the model that changed");Y.Assert.areSame("attr",c.attributeName,"The event for childModel1 should have been fired with the correct attribute name");Y.Assert.areSame("newValue1",c.newValue,"The attribute-specific event for childModel1 should have been fired with the newValue");Y.Assert.areSame("origValue1",c.oldValue,"The attribute-specific event for childModel1 should have been fired with the oldValue")},"The parent model should no longer fire events from the child collection after the child collection has been un-set from the parent":function(){var d=Data.Model.extend({attributes:["attr"]});var c=Data.Collection.extend({model:d});var e=Data.Model.extend({attributes:[{name:"myCollection",type:"collection"}]});var h=new d({attr:"origValue1"}),g=new d({attr:"origValue2"}),f=new c([h,g]),a=new e({myCollection:f});var b=0;a.on("change",function(k,j,l,i){b++});h.set("attr","newValue1");Y.Assert.areSame(1,b,"The call count should now be 1 (as an initial test)");a.set("myCollection",null);h.set("attr","newNewValue1");Y.Assert.areSame(2,b,"We should now only have 2 for the event firing count, as we un-set the child model from the parent (which was the +1), but shouldn't get 3 from childModel1's event")},"When a child collection is added to / removed from / reordered, the parent model should fire a 'change' event":function(){var o=Data.Model.extend({attributes:[{name:"childCollection",type:"collection"}],toString:function(){return"(ParentModel)"}});var e=Data.Model.extend({attributes:[{name:"attr",type:"string"}],toString:function(){return"(ChildModel)"}});var m=Data.Collection.extend({model:e,toString:function(){return"(Collection)"}});var h=new e({attr:1}),g=new e({attr:2}),d=new e({attr:3}),n=new m([h,g]),i=new o({childCollection:n});var b=0,q=0,k=0;n.on("addset",function(){b++});n.on("removeset",function(){q++});n.on("reorder",function(){k++});var c=0,j=0,f,p,l,a;i.on("change",function(u,r,t,s){c++;f=u;p=r;l=t;a=s});i.on("change:childCollection",function(t,s,r){j++});Y.Assert.areSame(0,b,"Initial condition: the addSetEventCount should be 0");Y.Assert.areSame(0,q,"Initial condition: the removeSetEventCount should be 0");Y.Assert.areSame(0,k,"Initial condition: the reorderEventCount should be 0");Y.Assert.areSame(0,c,"Initial condition: the changeCount should be 0");Y.Assert.areSame(0,j,"Initial condition: the collectionSpecificChangeEventCount should be 0");n.add(d);Y.Assert.areSame(1,b,"The addSetEventCount should now be 1");Y.Assert.areSame(0,q,"The removeSetEventCount should still be 0");Y.Assert.areSame(0,k,"The reorderEventCount should still be 0");Y.Assert.areSame(1,c,"The changeEventCount should now be 1 after an 'add' event");Y.Assert.areSame(1,j,"The collectionSpecificChangeEventCount should now be 1 after an 'add' event");Y.Assert.areSame(i,f,"The changed model should be the parent model for an add event");Y.Assert.areSame("childCollection",p,"The changed attribute should be the childCollection for an add event");Y.Assert.areSame(n,l,"The newValue for the change event should be the collection for an add event");Y.Assert.areSame(n,a,"The oldValue for the change event should be the collection for an add event");n.remove(d);Y.Assert.areSame(1,b,"The addSetEventCount should still be 1");Y.Assert.areSame(1,q,"The removeSetEventCount should now be 1");Y.Assert.areSame(0,k,"The reorderEventCount should still be 0");Y.Assert.areSame(2,c,"The changeEventCount should now be 2 after a 'remove' event");Y.Assert.areSame(2,j,"The collectionSpecificChangeEventCount should now be 2 after an 'remove' event");Y.Assert.areSame(i,f,"The changed model should be the parent model for a remove event");Y.Assert.areSame("childCollection",p,"The changed attribute should be the childCollection for a remove event");Y.Assert.areSame(n,l,"The newValue for the change event should be the collection for a remove event");Y.Assert.areSame(n,a,"The oldValue for the change event should be the collection for a remove event");n.insert(h,1);Y.Assert.areSame(1,b,"The addSetEventCount should still be 1");Y.Assert.areSame(1,q,"The removeSetEventCount should still be 1");Y.Assert.areSame(1,k,"The reorderEventCount should now be 1");Y.Assert.areSame(3,c,"The changeEventCount should now be 3 after a 'reorder' event");Y.Assert.areSame(3,j,"The collectionSpecificChangeEventCount should now be 3 after an 'reorder' event");Y.Assert.areSame(i,f,"The changed model should be the parent model for a reorder event");Y.Assert.areSame("childCollection",p,"The changed attribute should be the childCollection for a reorder event");Y.Assert.areSame(n,l,"The newValue for the change event should be the collection for a reorder event");Y.Assert.areSame(n,a,"The oldValue for the change event should be the collection for a reorder event")}},{name:'Test that the parent model "has changes" when an embedded collection is changed',"The parent model should have changes when a child embedded collection has changes":function(){var d=Data.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:true}]});var c=Data.Model.extend({attributes:[{name:"attr",type:"string"}]});var b=Data.Collection.extend({model:c});var e=new b([{attr:1},{attr:2}]);var a=new d({myCollection:e});e.getAt(0).set("attr","newValue");Y.Assert.isTrue(a.isModified(),"The parent model should be considered 'modified' while a model in its child collection is 'modified'");Y.Assert.isTrue(a.isModified("myCollection"),"The 'myCollection' attribute should be considered 'modified'")},"The parent model should *not* have changes when a child collection has changes, but is not 'embedded'":function(){var d=Data.Model.extend({attributes:[{name:"myCollection",type:"collection",embedded:false}]});var c=Data.Model.extend({attributes:[{name:"attr",type:"string"}]});var b=Data.Collection.extend({model:c});var e=new b([{attr:1},{attr:2}]);var a=new d({myCollection:e});e.getAt(0).set("attr","newValue");Y.Assert.isFalse(a.isModified(),"The parent model should not be considered 'modified' even though its child collection is 'modified', because the child is not 'embedded'")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with Nested Models",items:[{name:"Test setting nested Models","set() should only change the attribute that a nested Model is being set to if it is a different model than it already has":function(){var f=Data.Model.extend({attributes:[{name:"nestedModel",type:"model"}]});var e=Data.Model.extend({attributes:["attr1","attr2"]});var c=new f();var b=new e();var a=new e();var d=0;c.addListener("change:nestedModel",function(){d++});b.on("change:attr1",function(){});a.on("change:attr1",function(){});c.set("nestedModel",b);Y.Assert.areSame(1,d,"The model should have been set for the first time");c.set("nestedModel",b);Y.Assert.areSame(1,d,"The model should not have been re-set, because it is the same model that is already there");c.set("nestedModel",a);Y.Assert.areSame(2,d,"The new model (nestedModel2) should have been set");c.set("nestedModel",a);Y.Assert.areSame(2,d,"The new model (nestedModel2) should not have been re-set, because it is the same model that is already there");c.set("nestedModel",null);Y.Assert.areSame(3,d,"The attribute should have been set to null");c.set("nestedModel",b);Y.Assert.areSame(4,d,"The attribute should have been set to nestedModel1 after it had been null")}},{name:"Test the 'change' event for nested models","When an attribute has changed in a nested model, its parent model should fire the appropriate 'change' events":function(){var j=Data.Model.extend({attributes:[{name:"child",type:"model"}]});var c=Data.Model.extend({attributes:[{name:"attr"}]});var f=new c();var d=new j({child:f});var a=function(p,o,q,n){this.model=p;this.attributeName=o;this.newValue=q;this.oldValue=n};var h=0,k;d.on("change",function(p,o,q,n){h++;k=new a(p,o,q,n)});var m=0,l;d.on("change:child",function(o,p,n){m++;l=new a(o,"",p,n)});var g=0,i;d.on("change:child.*",function(p,o,q,n){g++;i=new a(p,o,q,n)});var e=0,b;d.on("change:child.attr",function(o,p,n){e++;b=new a(o,"",p,n)});f.set("attr","asdf");Y.Assert.areSame(1,h,"The parent's general change event should have fired exactly once");Y.Assert.areSame(d,k.model,"The parent's general change event should have fired with the parent model");Y.Assert.areSame("child",k.attributeName,"The parent's general change event should have fired with attributeName for the childModel");Y.Assert.areSame(f,k.newValue,"The parent's general change event should have fired with the new value");Y.Assert.areSame(f,k.oldValue,"The parent's general change event should have fired with the old value");Y.Assert.areSame(1,m,"The childModel-specific change event should have fired exactly once");Y.Assert.areSame(d,l.model,"The childModel-specific change event should have fired with the parent model");Y.Assert.areSame(f,l.newValue,"The childModel-specific change event should have fired with the new value");Y.Assert.areSame(f,l.oldValue,"The childModel-specific change event should have fired with the old value");Y.Assert.areSame(1,g,"The childModel-specific attribute change event should have fired exactly once");Y.Assert.areSame(f,i.model,"The childModel-specific attribute change event should have fired with the child model");Y.Assert.areSame("attr",i.attributeName,"The childModel-specific attribute change event should have fired with attributeName of the changed attribute");Y.Assert.areSame("asdf",i.newValue,"The childModel-specific attribute change event should have fired with the new value");Y.Assert.isUndefined(i.oldValue,"The childModel-specific attribute change event should have fired with the old value");Y.Assert.areSame(1,e,"The attribute-specific change event should have fired exactly once");Y.Assert.areSame(f,b.model,"The attribute-specific change event should have fired with the child model");Y.Assert.areSame("asdf",b.newValue,"The attribute-specific change event should have fired with the new value");Y.Assert.isUndefined(b.oldValue,"The attribute-specific change event should have fired with the old value")},"The parent model should no longer fire events from the child model after the child model has been un-set from the parent":function(){var d=Data.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});var c=Data.Model.extend({attributes:[{name:"attr"}]});var e=new c();var a=new d({child:e});var b=0;a.on("change",function(f,g,h){b++});e.set("attr","asdf");Y.Assert.areSame(1,b,"while the child model is attached, the change event count should have increased by 1");a.set("child",null);e.set("attr","asdf2");Y.Assert.areSame(2,b,"We should only have 2 for the event firing count, as we un-set the child model from the parent (which is the +1), but then events on the childModel beyond that should not be counted")},"When an attribute has changed in a deeply nested model, its parent model should fire a 'change' event":function(){var n=Data.Model.extend({attributes:[{name:"intermediate",type:"model"}],toString:function(){return"(ParentModel)"}});var k=Data.Model.extend({attributes:[{name:"child",type:"model"}],toString:function(){return"(IntermediateModel)"}});var b=Data.Model.extend({attributes:[{name:"attr"}],toString:function(){return"(ChildModel)"}});var a=new n(),l=new k(),o=new b();a.set("intermediate",l);l.set("child",o);var c=function(v,u,w,t){this.model=v;this.attributeName=u;this.newValue=w;this.oldValue=t};var s=0,q;a.on("change",function(v,u,w,t){s++;q=new c(v,u,w,t)});var h=0,p;a.on("change:intermediate",function(u,v,t){h++;p=new c(u,"",v,t)});var d=0,g;a.on("change:intermediate.*",function(v,u,w,t){d++;g=new c(v,u,w,t)});var m=0,j;a.on("change:intermediate.child",function(u,v,t){m++;j=new c(u,"",v,t)});var f=0,r;a.on("change:intermediate.child.*",function(v,u,w,t){f++;r=new c(v,u,w,t)});var e=0,i;a.on("change:intermediate.child.attr",function(u,v,t){e++;i=new c(u,"",v,t)});o.set("attr","asdf");Y.Assert.areSame(1,s,"The general change event should have fired exactly once");Y.Assert.areSame(a,q.model,"The general change event should have fired with the parent model");Y.Assert.areSame("intermediate",q.attributeName,"The general change event should have fired with the attributeName as the intermediate model");Y.Assert.areSame(l,q.newValue,"The general change event should have fired with the intermediate model as the new value");Y.Assert.areSame(l,q.oldValue,"The general change event should have fired with the intermediate model as the old value");Y.Assert.areSame(1,h,"The intermediateModel-specific change event should have fired exactly once");Y.Assert.areSame(a,p.model,"The intermediateModel-specific change event should have fired with the parent model");Y.Assert.areSame(l,p.newValue,"The intermediateModel-specific change event should have fired with the intermediate model as the new value");Y.Assert.areSame(l,p.oldValue,"The intermediateModel-specific change event should have fired with the intermediate model as the old value");Y.Assert.areSame(1,d,"The intermediateModel-specific attribute change event should have fired exactly once");Y.Assert.areSame(l,g.model,"The intermediateModel-specific attribute change event should have fired with the intermediateModel");Y.Assert.areSame("child",g.attributeName,"The intermediateModel-specific attribute change event should have fired with the child model attribute name");Y.Assert.areSame(o,g.newValue,"The intermediateModel-specific attribute change event should have fired with the childModel as the new value");Y.Assert.areSame(o,g.oldValue,"The intermediateModel-specific attribute change event should have fired with the childModel as the old value");Y.Assert.areSame(1,m,"The childModel-specific change event should have fired exactly once");Y.Assert.areSame(l,j.model,"The childModel-specific change event should have fired with the intermediateModel");Y.Assert.areSame(o,j.newValue,"The childModel-specific change event should have fired with the child model as the new value");Y.Assert.areSame(o,j.oldValue,"The childModel-specific change event should have fired with the child model as the old value");Y.Assert.areSame(1,f,"The childModel-specific attribute change event should have fired exactly once");Y.Assert.areSame(o,r.model,"The childModel-specific attribute change event should have fired with the childModel");Y.Assert.areSame("attr",r.attributeName,"The childModel-specific attribute change event should have fired with the child model");Y.Assert.areSame("asdf",r.newValue,"The childModel-specific attribute change event should have fired with the new value");Y.Assert.isUndefined(r.oldValue,"The childModel-specific attribute change event should have fired with the old value");Y.Assert.areSame(1,e,"The childModel attribute-specific change event should have fired exactly once");Y.Assert.areSame(o,i.model,"The childModel attribute-specific change event should have fired with the childModel");Y.Assert.areSame("asdf",i.newValue,"The childModel attribute-specific change event should have fired with the new value");Y.Assert.isUndefined(i.oldValue,"The childModel attribute-specific change event should have fired with the old value")}},{name:'Test that the parent model "has changes" (is modified) when an embedded model is changed',setUp:function(){this.ParentWithEmbeddedChildModel=Data.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});this.ParentWithNonEmbeddedChildModel=Data.Model.extend({attributes:[{name:"child",type:"model",embedded:false}]});this.ChildModel=Data.Model.extend({attributes:[{name:"attr",type:"string"},{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]})},"The parent model should have changes when a child embedded model has changes":function(){var b=new this.ChildModel();var a=new this.ParentWithEmbeddedChildModel({child:b});b.set("attr","newValue");Y.Assert.isTrue(b.isModified(),"As a base test, the child model should be considered 'modified'");Y.Assert.isTrue(a.isModified(),"The parent model should be considered 'modified' while its child model is 'modified'");Y.Assert.isTrue(a.isModified("child"),"The 'child' attribute should be considered 'modified'")},"The parent model should *not* have changes when a child model has changes, but is not 'embedded'":function(){var b=new this.ChildModel();var a=new this.ParentWithNonEmbeddedChildModel({child:b});b.set("attr","newValue");Y.Assert.isFalse(a.isModified(),"The parent model should not be considered 'modified' even though its child model is 'modified', because the child is not 'embedded'")},"Using the persistedOnly option, the parent model should be considered modified if an embedded child model has a persisted attribute change":function(){var b=new this.ChildModel({persistedAttr:"persisted",unpersistedAttr:"unpersisted"});var a=new this.ParentWithEmbeddedChildModel({child:b});b.set("persistedAttr","newValue");Y.Assert.isTrue(a.isModified({persistedOnly:true}),"The parent model should be considered modified because its child model has a change on a persisted attribute")},"Using the persistedOnly option, the parent model should *not* be considered modified if an embedded child model only has unpersisted attribute changes":function(){var b=new this.ChildModel({persistedAttr:"persisted",unpersistedAttr:"unpersisted"});var a=new this.ParentWithEmbeddedChildModel({child:b});b.set("unpersistedAttr","newValue");Y.Assert.isFalse(a.isModified({persistedOnly:true}),"The parent model should *not* be considered modified because its child model only has a change on an unpersisted attribute")},"Using the persistedOnly option and providing a specific attribute, the parent model should be considered modified if an embedded child model has a persisted attribute change":function(){var b=new this.ChildModel({persistedAttr:"persisted",unpersistedAttr:"unpersisted"});var a=new this.ParentWithEmbeddedChildModel({child:b});b.set("persistedAttr","newValue");Y.Assert.isTrue(a.isModified("child",{persistedOnly:true}),"The parent model should be considered modified because its child model has a change on a persisted attribute")},"Using the persistedOnly option and providing a specific attribute, the parent model should *not* be considered modified if an embedded child model only has unpersisted attribute changes":function(){var b=new this.ChildModel({persistedAttr:"persisted",unpersistedAttr:"unpersisted"});var a=new this.ParentWithEmbeddedChildModel({child:b});b.set("unpersistedAttr","newValue");Y.Assert.isFalse(a.isModified("child",{persistedOnly:true}),"The parent model should *not* be considered modified because its child model only has a change on an unpersisted attribute")}},{name:"Test getting changes from a parent model when an embedded model is changed",setUp:function(){this.ParentModel=Data.Model.extend({attributes:[{name:"child",type:"model",embedded:true}]});this.ChildModel=Data.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]})},"A child model with changes should be retrieved (with all of its data, because it is embedded) when any of its attributes has a change":function(){var c=new this.ChildModel({persistedAttr:"persistedValue",unpersistedAttr:"unpersistedValue"});var a=new this.ParentModel({child:c});Y.Assert.areSame(0,_.keys(a.getChanges()).length,"Initial condition: there should be no changes");c.set("persistedAttr","newPersistedValue");var b=a.getChanges();Y.Assert.areSame(1,_.keys(b).length,"There should be 1 property in the 'changes' object");Y.ObjectAssert.hasKeys(["child"],b,"'child' should be the property in the 'changes' object");Y.Assert.areSame(2,_.keys(b.child).length,"There should be 2 properties in the 'child' changes object");Y.Assert.areSame("newPersistedValue",b.child.persistedAttr,"persistedAttr should exist in the 'child' changes, with the new value");Y.Assert.areSame("unpersistedValue",b.child.unpersistedAttr,"unpersistedAttr should exist in the 'child' changes, with its original value")},"With the 'persistedOnly' option, a child model with changes should only be retrieved (with all of its persisted data, because it is embedded) when any of its *persisted* attributes has a change":function(){var c=new this.ChildModel({persistedAttr:"persistedValue",unpersistedAttr:"unpersistedValue"});var a=new this.ParentModel({child:c});Y.Assert.areSame(0,_.keys(a.getChanges()).length,"Initial condition: there should be no changes");c.set("persistedAttr","newPersistedValue");var b=a.getChanges({persistedOnly:true});Y.Assert.areSame(1,_.keys(b).length,"There should be 1 property in the 'changes' object");Y.ObjectAssert.hasKeys(["child"],b,"'child' should be the property in the 'changes' object");Y.Assert.areSame(1,_.keys(b.child).length,"There should be only 1 property (for the persisted one) in the 'child' changes object");Y.Assert.areSame("newPersistedValue",b.child.persistedAttr,"persistedAttr should exist in the 'child' changes, with the new value")},"With the 'persistedOnly' option, a child model that only has changes to non-persisted attributes should *not* be retrieved with getChanges()":function(){var c=new this.ChildModel({persistedAttr:"persistedValue",unpersistedAttr:"unpersistedValue"});var a=new this.ParentModel({child:c});Y.Assert.areSame(0,_.keys(a.getChanges()).length,"Initial condition: there should be no changes");c.set("unpersistedAttr","newUnpersistedValue");var b=a.getChanges({persistedOnly:true});Y.Assert.areSame(0,_.keys(b).length,"There should be no properties in the 'changes' object")}}]}));tests.integration.add(new Ext.test.TestSuite({name:"Model with ObjectAttribute",items:[{name:"Test defaultValue of ObjectAttribute","The defaultValue for an ObjectAttribute should be null":function(){var b=Data.Model.extend({attributes:[{name:"attr",type:"object"}]});var a=new b();Y.Assert.isNull(a.get("attr"))}}]}));tests.integration.persistence.add(new Ext.test.TestSuite({name:"RestProxy with Nested Models",items:[{name:"Test updating when nested model attributes are changed",setUp:function(){this.ajaxCallCount=0;this.RestProxy=Data.persistence.RestProxy.extend({ajax:_.bind(function(){this.ajaxCallCount++;return{}},this)});this.ParentModel=Data.Model.extend({attributes:[{name:"id",type:"string"},{name:"child",type:"model",embedded:true}]});this.ChildModel=Data.Model.extend({attributes:[{name:"persistedAttr",type:"string"},{name:"unpersistedAttr",type:"string",persist:false}]})},"The parent model should *not* be persisted when only a non-persisted attribute of a nested model is changed":function(){var b=0;var e=new this.ChildModel();var c=new this.ParentModel({id:1,child:e});e.set("unpersistedAttr","newValue");var d=new this.RestProxy(),a=d.update(c);Y.Assert.isNull(a,"The update() method should have returned null, because there should have been nothing to persist")}}]}));