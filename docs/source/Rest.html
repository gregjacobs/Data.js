<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*global define */
define( [
	'jquery',
	'lodash',
	'Class',
	'data/persistence/proxy/Proxy',
	'data/persistence/proxy/Ajax'
], function( jQuery, _, Class, Proxy, AjaxProxy ) {
	
<span id='data-persistence-proxy-Rest'>	/**
</span>	 * @class data.persistence.proxy.Rest
	 * @extends data.persistence.proxy.Ajax
	 * 
	 * RestProxy is responsible for performing CRUD requests in a RESTful manner for a given Model on the server.
	 */
	var RestProxy = Class.extend( AjaxProxy, {
		
<span id='data-persistence-proxy-Rest-cfg-urlRoot'>		/**
</span>		 * @cfg {String} urlRoot
		 * 
		 * The url to use in a RESTful manner to perform CRUD requests. Ex: `/tasks`.
		 * 
		 * The {@link data.Model#idAttribute id} of the {@link data.Model} being read/updated/deleted
		 * will automatically be appended to this url. Ex: `/tasks/12`
		 */
		urlRoot : &quot;&quot;,
		
<span id='data-persistence-proxy-Rest-cfg-incremental'>		/**
</span>		 * @cfg {Boolean} incremental
		 * 
		 * True to have the RestProxy only provide data that has changed to the server when
		 * updating a model. By using this, it isn't exactly following REST per se, but can
		 * optimize requests by only providing a subset of the full model data. Only enable
		 * this if your server supports this.
		*/
		incremental : false,
		
<span id='data-persistence-proxy-Rest-cfg-rootProperty'>		/**
</span>		 * @cfg {String} rootProperty
		 * 
		 * If the server requires the data to be wrapped in a property of its own, use this config
		 * to specify it. For example, if PUT'ing a Task's data needs to look like this, use this config:
		 * 
		 *     {
		 *         &quot;task&quot; : {
		 *             &quot;text&quot; : &quot;Do Something&quot;,
		 *             &quot;isDone&quot; : false
		 *         }
		 *     }
		 * 
		 * This config should be set to &quot;task&quot; in this case.
		 */
		rootProperty : &quot;&quot;,
		
<span id='data-persistence-proxy-Rest-cfg-createMethod'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		createMethod : 'POST',

<span id='data-persistence-proxy-Rest-cfg-readMethod'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		readMethod : 'GET',

<span id='data-persistence-proxy-Rest-cfg-updateMethod'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		updateMethod : 'PUT',

<span id='data-persistence-proxy-Rest-cfg-destroyMethod'>		/**
</span>		 * @cfg
		 * @inheritdoc
		 */
		destroyMethod : 'DELETE',
		
		
<span id='data-persistence-proxy-Rest-method-setRootProperty'>		/**
</span>		 * Accessor to set the {@link #rootProperty} after instantiation.
		 * 
		 * @param {String} rootProperty The new {@link #rootProperty} value. This can be set to an empty string 
		 *   to remove the {@link #rootProperty}.
		 */
		setRootProperty : function( rootProperty ) {
			this.rootProperty = rootProperty;
		},
		
		
<span id='data-persistence-proxy-Rest-method-create'>		/**
</span>		 * Creates the Model on the server.
		 * 
		 * @param {data.persistence.request.Create} request The CreateRequest instance that holds the model(s) 
		 *   to be created on the REST server.
		 * @return {jQuery.Promise} A Promise object which is resolved when the request is complete.
		 *   `done`, `fail`, and `always` callbacks are called with the `request` object provided to 
		 *   this method as the first argument.
		 */
		create : function( request ) {
			var me = this,  // for closures
			    deferred = new jQuery.Deferred(),
			    model = request.getModels()[ 0 ],
			    dataToPersist = model.getData( { persistedOnly: true, raw: true } );
			
			// Handle needing a different &quot;root&quot; wrapper object for the data
			if( this.rootProperty ) {
				var dataWrap = {};
				dataWrap[ this.rootProperty ] = dataToPersist;
				dataToPersist = dataWrap;
			}
			
			this.ajax( {
				url         : this.buildUrl( 'create', model.getId() ),
				type        : this.getHttpMethod( 'create' ),
				dataType    : 'text',
				data        : JSON.stringify( dataToPersist ),
				contentType : 'application/json'
			} ).then(
				function( data, textStatus, jqXHR ) {
					if( data ) {  // data may or may not be returned by a server on a 'create' request
						request.setResultSet( me.reader.read( data ) );
					}
					request.setSuccess();
					deferred.resolve( request );
				},
				function( jqXHR, textStatus, errorThrown ) {
					request.setException( { textStatus: textStatus, errorThrown: errorThrown } );
					deferred.reject( request );
				}
			);
			
			return deferred.promise();
		},
		
		
<span id='data-persistence-proxy-Rest-method-read'>		/**
</span>		 * Reads the Model from the server.
		 * 
		 * @param {data.persistence.request.Read} request The ReadRequest instance that holds the model(s) 
		 *   to be read from the REST server.
		 * @return {jQuery.Promise} A Promise object which is resolved when the request is complete.
		 *   `done`, `fail`, and `always` callbacks are called with the `request` object provided to 
		 *   this method as the first argument.
		 */
		read : function( request ) {
			var me = this,  // for closures
			    deferred = new jQuery.Deferred();
			
			this.ajax( {
				url      : this.buildUrl( 'read', request.getModelId() ),
				type     : this.getHttpMethod( 'read' ),
				dataType : 'json'
			} ).then(
				function( data, textStatus, jqXHR ) {
					request.setResultSet( me.reader.read( data ) );
					request.setSuccess();
					deferred.resolve( request );
				},
				function( jqXHR, textStatus, errorThrown ) {
					request.setException( { textStatus: textStatus, errorThrown: errorThrown } );
					deferred.reject( request );
				}
			);
			
			return deferred.promise();
		},
		
		
<span id='data-persistence-proxy-Rest-method-update'>		/**
</span>		 * Updates the given Model on the server.  This method uses &quot;incremental&quot; updates, in which only the changed attributes of the `model`
		 * are persisted.
		 * 
		 * @param {data.persistence.request.Update} request The UpdateRequest instance that holds the model(s) 
		 *   to be updated on the REST server.
		 * @return {jQuery.Promise} A Promise object which is resolved when the request is complete.
		 *   `done`, `fail`, and `always` callbacks are called with the `request` object provided to 
		 *   this method as the first argument.
		 */
		update : function( request ) {
			var me = this,  // for closures
			    model = request.getModels()[ 0 ],
			    changedData = model.getChanges( { persistedOnly: true, raw: true } ),
			    deferred = new jQuery.Deferred();
			
			// Short Circuit: If there is no changed data in any of the attributes that are to be persisted, there is no need to make a 
			// request. Resolves the deferred and return out.
			if( _.isEmpty( changedData ) ) {
				deferred.resolve( request );
				return deferred.promise();
			}
			
			
			// Set the data to persist, based on if the persistence proxy is set to do incremental updates or not
			var dataToPersist;
			if( this.incremental ) {
				dataToPersist = changedData;   // uses incremental updates, we can just send it the changes
			} else {
				dataToPersist = model.getData( { persistedOnly: true, raw: true } );  // non-incremental updates, provide all persisted data
			}
			
			
			// Handle needing a different &quot;root&quot; wrapper object for the data
			if( this.rootProperty ) {
				var dataWrap = {};
				dataWrap[ this.rootProperty ] = dataToPersist;
				dataToPersist = dataWrap;
			}
			
			
			// Finally, persist to the server
			this.ajax( {
				url         : this.buildUrl( 'update', model.getId() ),
				type        : this.getHttpMethod( 'update' ),
				dataType    : 'text',
				data        : JSON.stringify( dataToPersist ),
				contentType : 'application/json'
			} ).then(
				function( data, textStatus, jqXHR ) {
					if( data ) {  // data may or may not be returned by a server on an 'update' request
						request.setResultSet( me.reader.read( data ) );
					}
					request.setSuccess();
					deferred.resolve( request );
				},
				function( jqXHR, textStatus, errorThrown ) {
					request.setException( { textStatus: textStatus, errorThrown: errorThrown } );
					deferred.reject( request );
				}
			);
			
			return deferred.promise();
		},
		
		
<span id='data-persistence-proxy-Rest-method-destroy'>		/**
</span>		 * Destroys (deletes) the Model on the server.
		 * 
		 * Note that this method is not named &quot;delete&quot; as &quot;delete&quot; is a JavaScript reserved word.
		 * 
		 * @param {data.persistence.request.Destroy} request The DestroyRequest instance that holds the model(s) 
		 *   to be destroyed on the REST server.
		 * @return {jQuery.Promise} A Promise object which is resolved when the request is complete.
		 *   `done`, `fail`, and `always` callbacks are called with the `request` object provided to 
		 *   this method as the first argument.
		 */
		destroy : function( request ) {
			var deferred = new jQuery.Deferred(),
			    model = request.getModels()[ 0 ];
			
			this.ajax( {
				url      : this.buildUrl( 'destroy', model.getId() ),
				type     : this.getHttpMethod( 'destroy' ),
				dataType : 'text'  // in case the server returns nothing. Otherwise, jQuery might make a guess as to the wrong data type (such as JSON), and try to parse it, causing the `error` callback to be executed instead of `success`
			} ).then(
				function( data, textStatus, jqXHR ) {
					request.setSuccess();
					deferred.resolve( request );
				},
				function( jqXHR, textStatus, errorThrown ) {
					request.setException( { textStatus: textStatus, errorThrown: errorThrown } );
					deferred.reject( request );
				}
			);
			
			return deferred.promise();
		},
		
		
		// -------------------
		
		
<span id='data-persistence-proxy-Rest-method-buildUrl'>		/**
</span>		 * Builds the URL to use to do CRUD requests.
		 * 
		 * @protected
		 * @param {String} action The action being taken. Must be one of: 'create', 'read', 'update', or 'destroy'.
		 * @param {String} modelId The ID for the model that a url is being built for.
		 * @return {String} The url to use.
		 */
		buildUrl : function( action, modelId ) {
			var url = this.urlRoot;
			
			// Use the model's ID to set the url if we're not creating.
			// In the read case where there is no particular model to load (i.e. loading a collection),
			// then we skip this as well, as we want to load *all* (or at least a range of) models of the 
			// particular resource.
			if( action !== 'create' &amp;&amp; modelId !== undefined ) {
				if( !url.match( /\/$/ ) ) {
					url += '/';  // append trailing slash if it's not there
				}
				
				url += encodeURIComponent( modelId );
			}
			
			return url;
		}
		
	} );
	
	// Register the persistence proxy so that it can be created by an object literal with a `type` property
	Proxy.register( 'rest', RestProxy );
	
	return RestProxy;
	
} );</pre>
</body>
</html>
